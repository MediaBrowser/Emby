<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Représente le résultat d'une opération de tri.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Représente le résultat d'une opération de tri.</summary>
      <typeparam name="T">Type du contenu de la source de données.Ce paramètre de type est covariant. Autrement dit, vous pouvez utiliser le type que vous avez spécifié ou tout type plus dérivé. Pour plus d'informations sur la covariance et la contravariance, consultez Covariance et contravariance dans les génériques.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données n'est pas défini.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtient le type des éléments retournés lors de l'exécution de l'arborescence d'expression associée à cette instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente le type des éléments retournés lorsque l'arborescence d'expression associé à cet objet est exécutée.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtient l'arborescence d'expression associée à l'instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.Expression" /> associée à cette instance de l'interface <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtient le fournisseur de requêtes associé à cette source de données.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryProvider" /> associé à cette source de données.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données est connu.</summary>
      <typeparam name="T">Type des données contenues dans la source de données.Ce paramètre de type est covariant. Autrement dit, vous pouvez utiliser le type que vous avez spécifié ou tout type plus dérivé. Pour plus d'informations sur la covariance et la contravariance, consultez Covariance et contravariance dans les génériques.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Définit des méthodes destinées à créer et exécuter des requêtes décrites par un objet <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TElement">Type des éléments du <see cref="T:System.Linq.IQueryable`1" /> retourné.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête fortement typée représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TResult">Type de la valeur qui résulte de l'exécution de la requête.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Représente une expression qui comporte un opérateur binaire.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud d'arborescence de l'expression peut être réduit, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtient la fonction de conversion de type utilisée par une opération de fusion ou d'assignation composée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns>true si le nœud représente un appel levé ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>true si le type de retour de l'opérateur est levé vers un type nullable ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtient l'opérande gauche de l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche de l'opération binaire.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtient la méthode d'implémentation pour l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Réduit le nœud d'expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtient l'opérande droit de l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit de l'opération binaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="left">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> du résultat. </param>
      <param name="conversion">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> du résultat.</param>
      <param name="right">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> du résultat. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Représente un bloc qui contient une séquence d'expressions où les variables peuvent être définies.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtient les expressions contenues dans ce bloc.</summary>
      <returns>Collection en lecture seule qui contient toutes les expressions contenues dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtient la dernière expression contenue dans ce bloc.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la dernière expression contenue dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> du résultat. </param>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> du résultat. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtient les variables définies dans ce bloc.</summary>
      <returns>Collection en lecture seule qui contient toutes les variables définies dans ce bloc.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Représente une instruction catch dans un bloc try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtient le corps du bloc catch.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtient le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtient le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variable">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> du résultat.</param>
      <param name="filter">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> du résultat.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtient une référence pour l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Représente une expression qui comporte un opérateur conditionnel.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtient l'expression à exécuter si le test a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtient l'expression à exécuter si le test a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtient le test de l'opération conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test de l'opération conditionnelle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="test">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> du résultat.</param>
      <param name="ifTrue">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> du résultat.</param>
      <param name="ifFalse">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Représente une expression qui a une valeur de constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtient la valeur de l'expression constante.</summary>
      <returns>
        <see cref="T:System.Object" /> égal à la valeur de l'expression représentée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Émet ou efface un point de séquence pour les informations de débogage.Cela permet au débogueur de mettre en surbrillance le code source correct lors du débogage.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtient la colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtient la ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtient la valeur qui indique si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence.</summary>
      <returns>True si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtient la colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtient la ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Représente la valeur par défaut d'un type ou une expression vide.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Représente un initialiseur pour un élément unique d'une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtient la méthode d'instance utilisée pour ajouter un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtient la collection d'arguments passés à une méthode qui ajoute un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments d'une méthode qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Retourne une représentation textuelle d'un objet <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Représentation textuelle de l'objet <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fournit la classe de base de laquelle sont dérivées les classes qui représentent des nœuds d'arborescence d'expression.Contient également des méthodes de fabrique static (Shared en Visual Basic) pour créer les divers types de nœuds.Il s'agit d'une classe abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND au niveau du bit.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau multidimensionnel.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="array">Expression qui représente le tableau multidimensionnel.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des expressions utilisées pour indexer le tableau.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="array">Expression qui représente le tableau à indexer.</param>
      <param name="indexes">Tableau qui contient des expressions utilisées pour indexer le tableau.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang supérieur à un.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ouLe rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang un.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="index" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ou<paramref name="array" />.Type représente un type de tableau dont le rang n'est pas 1.ou<paramref name="index" />.Type ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau multidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="array">Tableau d'instances <see cref="T:System.Linq.Expressions.Expression" />, index pour l'opération d'index de tableau.</param>
      <param name="indexes">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ouLe rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression permettant d'obtenir la longueur d'un tableau unidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> et la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> est égale à <paramref name="array" />.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égal à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> et dont <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété représentée par <paramref name="member" /> n'a pas d'accesseur set.ou<paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre à l'aide d'une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> a la valeur <paramref name="expression" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLa propriété accessible par <paramref name="propertyAccessor" /> n'a pas d'accesseur set.ou<paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient trois expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient quatre expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
      <param name="arg4">Cinquième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui ne prend aucun argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.ouLe nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance.(Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend trois arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance.(Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.ou<paramref name="arguments" /> n'est pas null et un ou plusieurs de ses éléments sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.ouLe nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> est égale à <paramref name="instance" />, dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'instance spécifiée, et dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> dont la valeur de propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> fera l'objet d'une recherche de méthode spécifique.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> ou <paramref name="methodName" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="instance" />.Type ou ses types de base.ouPlusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="instance" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique (méthode partagée en Visual Basic).</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arguments">Collection de <see cref="T:System.Linq.Expressions.Expression" /> qui représente les arguments de l'appel.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) qui prend un seul argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant trois arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant quatre arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant cinq arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) comportant des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode static (Shared en Visual Basic) à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode static (Shared en Visual Basic) spécifiée, et dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type contenant la méthode static (Shared en Visual Basic) spécifiée.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="methodName" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="type" /> ou ses types de base.ouPlusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="type" /> ou ses types de base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indique que le nœud peut être réduit à un nœud plus simple.Si la valeur retournée est true, Reduce() peut être appelé pour produire la forme réduite.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec une référence à l'objet <see cref="T:System.Exception" /> intercepté pour une utilisation dans le corps du gestionnaire.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" /> et une référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body">Corps de l'instruction Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" />, sans référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour la suppression d'un point de séquence.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour le nettoyage d'un point de séquence.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion, à partir d'une fonction de conversion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.ou<paramref name="conversion" /> n'est pas null et <paramref name="conversion" />.Type est un type délégué qui ne prend pas exactement un argument.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> représente un type qui ne peut pas être assigné au type de paramètre du type délégué <paramref name="conversion" />.Type.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> n'est pas égale au type de retour du type délégué <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> ou <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type n'est pas <see cref="T:System.Boolean" />.ou<paramref name="ifTrue" />.Type n'est pas égal à <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</returns>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> n'est pas null et <paramref name="type" /> ne peut pas être assigné à partir du type dynamique de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion pour laquelle la méthode d'implémentation est spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.ou<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.ouLe type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.ou<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible et pour lequel la méthode d'implémentation est spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.ou<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.ouLe type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.ou<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> avec l'étendue spécifiée.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
      <param name="startLine">Ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure à 0.</param>
      <param name="startColumn">Colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure à 0.</param>
      <param name="endLine">Ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure ou égale à la ligne de début.</param>
      <param name="endColumn">Colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la ligne de fin est la même que la ligne de début, elle doit être supérieure ou égale à la colonne de début.Dans tous les cas, elle doit être supérieure à 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> comme deuxième argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par <paramref name="addMethod" /> n'est pas nommée "Add" (non respect de la casse).ouLa méthode représentée par <paramref name="addMethod" /> n'est pas une méthode d'instance.ou<paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par <paramref name="addMethod" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un tableau de valeurs comme deuxième argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par addMethod n'est pas nommée "Add" (non respect de la casse).ouLa méthode représentée par addMethod n'est pas une méthode d'instance.ouarguments ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par addMethod.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crée une expression vide qui a le type <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> est égale à <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur XOR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur XOR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Pour static (Shared en Visual Basic), <paramref name="expression" /> doit être null.</param>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> a la valeur null.ouLe champ représenté par <paramref name="field" /> n'est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration du champ représenté par <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ à partir du nom du champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ désigné par <paramref name="fieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient un champ nommé <paramref name="fieldName" />.Cette valeur peut être null pour les champs statiques.</param>
      <param name="fieldName">Nom d'un champ auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="fieldName" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Aucun champ nommé <paramref name="fieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
      <param name="expression">Objet conteneur du champ.Cette valeur peut être null pour les champs statiques.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient le champ.</param>
      <param name="fieldName">Champ auquel accéder.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crée un objet <see cref="T:System.Type" /> qui représente un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <returns>Type d'un délégué System.Action qui a les arguments de type spécifiés.</returns>
      <param name="typeArgs">Tableau contenant jusqu'à seize objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contient plus de seize éléments.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtient un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué générique System.Func ou System.Action comportant des arguments de type spécifiques.</summary>
      <returns>Type délégué.</returns>
      <param name="typeArgs">Arguments de type du délégué.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques.Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <returns>Type d'un délégué System.Func qui a les arguments de type spécifiés.</returns>
      <param name="typeArgs">Tableau contenant entre un et dix-sept objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contient moins d'un élément ou plus de dix sept éléments.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ».La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec une instruction if.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ont les valeurs spécifiées.Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ayant pour valeur l'expression par défaut et dont le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec des instructions if et else.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.Le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de la valeur de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l'expression lambda spécifiés aux arguments fournis.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression lambda ou le délégué auquel appliquer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels le délégué ou l'expression lambda sont appliqués.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l'expression lambda spécifiés aux arguments fournis.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué ou l'expression lambda à appliquer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué ou l'expression lambda est appliquée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Indique si l'expression prend la valeur false.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Indique si l'expression prend la valeur false.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Indique si l'expression prend la valeur true.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Indique si l'expression prend la valeur true.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type void et aucun nom.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette sans valeur par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sans valeur par défaut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette avec la valeur par défaut donnée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> avec la valeur par défaut donnée.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
      <param name="defaultValue">Valeur de ce <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via un flux de contrôle normal.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et le nom donné.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Nom de l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type donné.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type et le nom donnés.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
      <param name="name">Nom de l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> n'est pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> n'est pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contient plus de seize éléments.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour la génération des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression`1.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour la génération des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale. </param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée. </param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLe <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLe <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLe <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLe <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode d'instance nommée "Add" (non respect de la casse) n'est déclarée dans <paramref name="newExpression" />.Type ou son type de base.ouLa méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.ouLe type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.ouIl existe plusieurs méthodes compatibles à l'argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode d'instance nommée "Add" (non respect de la casse) n'est déclarée dans <paramref name="newExpression" />.Type ou son type de base.ouLa méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.ouLe type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.ouIl existe plusieurs méthodes compatibles à l'argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance nommée "Add" (non respect de la casse), qui ajoute un élément à une collection.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.ou<paramref name="addMethod" /> n'est pas null et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.ou<paramref name="addMethod" /> n'est pas null et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est null et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance prenant un argument, qui ajoute un élément à une collection.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.ou<paramref name="addMethod" /> n'est pas null et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.ou<paramref name="addMethod" /> n'est pas null et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est null et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps et la cible d'instruction Break donnés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
      <param name="continue">Cible d'instruction Continue utilisée par le corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, à partir des opérandes gauche et droit, en appelant une méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit et la méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit, la méthode d'implémentation et la fonction de conversion de type, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.Ce paramètre est utilisé uniquement si <paramref name="binaryType" /> est un champ <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou une assignation composée.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec les éléments spécifiés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut du <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> spécifié.La valeur passée à l'étiquette au moment du saut peut également être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à <paramref name="kind" />, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> du <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée dans un objet.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Doit avoir la valeur Null si la propriété est static (shared en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la propriété à indexer.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) qui contient les arguments qui seront utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ ou à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet auquel appartient le membre.Cette valeur peut être null pour les membres statiques.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui décrit le champ ou la propriété auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc Try avec les éléments spécifiés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="type">Type de résultat de l'expression Try.Si Null, le corps et tous les gestionnaires doivent avoir le même type.</param>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.Passez la valeur Null si aucun bloc Finally n'est associé au bloc Try.</param>
      <param name="fault">Corps du bloc Fault.Passez la valeur Null si aucun bloc Fault n'est associé au bloc Try.</param>
      <param name="handlers">Collection de <see cref="T:System.Linq.Expressions.CatchBlock" />s qui représente les instructions catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez null le cas échéant).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande et une méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez null le cas échéant).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Représente une expression qui crée un nouvel objet et initialise une propriété de l'objet.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié qui ne prend pas d'arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> a la valeur spécifiée.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le constructeur représenté par <paramref name="constructor" /> a au moins un paramètre.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.ouUn élément de <paramref name="arguments" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.ouUn élément de <paramref name="arguments" /> est null.ouUn élément de <paramref name="members" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.ouLe paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.ouUn élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés sous forme de tableau.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.ouUn élément de <paramref name="arguments" /> est null.ouUn élément de <paramref name="members" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.ouLe paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.ouUn élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.ouUn élément de <paramref name="arguments" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La longueur du paramètre <paramref name="arguments" /> correspond au nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur sans paramètre du type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> égale à <see cref="T:System.Reflection.ConstructorInfo" />, laquelle représente le constructeur sans paramètre pour le type spécifié.</returns>
      <param name="type">
        <see cref="T:System.Type" /> ayant un constructeur qui ne prend pas d'arguments.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le type représenté par <paramref name="type" /> n'a pas de constructeur sans paramètres.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="bounds">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> a la valeur null.ouUn élément de <paramref name="bounds" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="bounds">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> a la valeur null.ouUn élément de <paramref name="bounds" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> a la valeur null.ouUn élément de <paramref name="initializers" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément du paramètre <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type représenté par <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> a la valeur null.ouUn élément de <paramref name="initializers" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtient le type de nœud de ce <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Une des valeurs de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Retourne l'expression qui représente le complément à 1.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Retourne l'expression qui représente le complément à 1.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ont les valeurs spécifiées.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable, utilisé à des fins de débogage ou d'impression uniquement.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété à l'aide d'une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null.ouLa méthode représentée par <paramref name="propertyAccessor" /> n'est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="propertyAccessor" />.ouLa méthode représentée par <paramref name="propertyAccessor" /> n'est pas une méthode d'accesseur de propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="property">
        <see cref="T:System.Reflection.PropertyInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> a la valeur null.ouLa propriété représentée par <paramref name="property" /> n'est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la propriété que <paramref name="property" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente le champ désigné par <paramref name="propertyName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété nommée <paramref name="propertyName" />.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyName">Nom d'une propriété à laquelle accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyName" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété nommée <paramref name="propertyName" /> n'est définie dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="propertyName">Nom de l'indexeur.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui accède à une propriété.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
      <param name="expression">Objet contenant la propriété.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="type">Objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient la propriété.</param>
      <param name="propertyName">Propriété à laquelle accéder.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété ou un champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> est égale à <paramref name="expression" />, et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> ou à <see cref="T:System.Reflection.FieldInfo" /> qui représente la propriété ou le champ désigné par <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété ou un champ nommé <paramref name="propertyOrFieldName" />.Cette valeur peut être null pour les membres statiques.</param>
      <param name="propertyOrFieldName">Nom d'une propriété ou d'un champ auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété ou aucun champ nommé <paramref name="propertyOrFieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression ayant une valeur de constante de type <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Réduit le nœud en une expression plus simple.Si CanReduce retourne la valeur true, cela doit retourner une expression valide.Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Réduit le nœud en une expression plus simple.Si CanReduce retourne la valeur true, cela doit retourner une expression valide.Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Réduit l'expression à un type de nœud connu (qui n'est pas un nœud Extension) ou retourne simplement l'expression s'il s'agit d'un type déjà connu.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité des références.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité des références.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'une exception avec un type donné.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
      <param name="variables">Collection d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
      <param name="variables">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch sans casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchCase" /> pour une utilisation dans un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> a la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
      <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la levée d'une exception avec un type donné.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
      <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Retourne une représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch mais ni une erreur, ni un bloc Finally.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch et un bloc Finally.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Fault et aucune instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="fault">Corps du bloc Fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Finally et aucune instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <returns>True si le type délégué System.Action générique a été créé pour un <paramref name="typeArgs" /> spécifique, false dans le cas contraire.</returns>
      <param name="typeArgs">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Action.</param>
      <param name="actionType">Cette méthode retourne le type délégué System.Action générique qui comporte des arguments de type spécifiques.Contient la valeur Null s'il n'y a aucun délégué System.Action générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques.Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <returns>true si le type délégué System.Func générique a été créé pour un <paramref name="typeArgs" /> spécifique ; sinon, false.</returns>
      <param name="typeArgs">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Func.</param>
      <param name="funcType">Cette méthode retourne le type délégué System.Func générique qui comporte des arguments de type spécifiques.Contient la valeur null s'il n'existe aucun délégué System.Func générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une référence explicite ou une conversion boxing où la valeur null est fournie en cas d'échec de la conversion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> qui compare l'identité de type à l'exécution.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> et dont les propriétés <see cref="T:System.Linq.Expressions.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="T:System.Linq.Expressions.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente un unboxing explicite.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objet <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer un unboxing.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable.Ce nom est utilisé à des fins de débogage ou d'impression uniquement.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Réduit le nœud puis appelle le délégué visiteur sur l'expression réduite.La méthode lève une exception si le nœud n'est pas réductible.</summary>
      <returns>Expression qui est visitée ou expression qui doit la remplacer dans l'arborescence.</returns>
      <param name="visitor">Instance de <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Représente une expression lambda fortement typée comme une structure de données sous forme d'arborescence de l'expression.Cette classe ne peut pas être héritée.</summary>
      <typeparam name="TDelegate">Type du délégué représenté par le <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compile l'expression lambda décrite par l'arborescence de l'expression dans le code exécutable et produit un délégué qui représente l'expression lambda.</summary>
      <returns>Délégué de type <paramref name="TDelegate" /> qui représente l'expression lambda compilée décrite par <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> du résultat.</param>
      <param name="parameters">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> du résultat. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Décrit les types de nœuds d'une arborescence d'expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Opération d'addition, telle que a + b, sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Opération d'assignation composée d'addition, telle que (a += b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Opération d'assignation composée d'addition, telle que (a += b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Opération d'addition telle que (a + b) avec vérification de dépassement pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Opération AND logique ou au niveau du bit, telle que (a &amp; b) en C# et (a And b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Opération AND conditionnelle qui évalue la deuxième opérande uniquement si la première opérande a la valeur true.Correspond à (a &amp;&amp; b) en C# et (a AndAlso b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Opération d'assignation composée AND au niveau du bit ou logique, telle que (a &amp;= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Opération d'indexation dans un tableau unidimensionnel, telle que array[index] en C# ou array(index) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Opération qui obtient la longueur d'un tableau unidimensionnel, telle que array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Opération d'assignation telle que (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Bloc d'expressions.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Appel de méthode, comme dans l'expression obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nœud qui représente une opération de fusion nulle, telle que (a ?? b) en C# ou If(a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Opération conditionnelle, telle que a &gt; b ? a : b en C# ou If(a &gt; b, a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Valeur de constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Opération de cast ou de conversion, telle que (SampleType)obj en C# ou CType(obj, SampleType) en Visual Basic.Pour une conversion numérique, si la valeur convertie est trop grande pour le type de destination, aucune exception n'est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Opération de cast ou de conversion, telle que (SampleType)obj en C# ou CType(obj, SampleType) en Visual Basic.Pour une conversion numérique, si la valeur convertie ne correspond pas au type cible, une exception est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informations de débogage.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Opération de décrémentation unaire, telle que (a - 1) en C# et Visual Basic.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Valeur par défaut.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Opération de division, telle que (a / b), pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Opération d'assignation composée de division, telle que (a /= b), pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Opération dynamique.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nœud qui représente une comparaison d'égalité, telle que (a == b) en C# ou (a = b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Opération XOR au niveau du bit ou logique, telle que (a ^ b) en C# ou (a Xor b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Opération d'assignation composée XOR au niveau du bit ou logique, telle que (a ^= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Expression d'extension.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expression GoTo, telle que goto Label en C# ou GoTo Label en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparaison numérique "supérieur à", telle que (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparaison « supérieur ou égal à », telle que (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Opération d'incrémentation unaire, telle que (a + 1) en C# et Visual Basic.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Opération d'index ou opération qui accède à une propriété qui prend des arguments. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Opération qui appelle un délégué ou une expression lambda, telle que sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valeur de condition false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valeur de condition true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Étiquette.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Expression lambda, telle que a =&gt; a + a en C# ou Function(a) a + a en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Opération de décalage vers la gauche au niveau du bit, telle que (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Assignation composée de décalage vers la gauche au niveau du bit, telle que (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparaison numérique "inférieur à", telle que (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparaison "inférieur ou égal à", telle que (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Opération qui crée un objet <see cref="T:System.Collections.IEnumerable" /> et l'initialise à partir d'une liste d'éléments, telle que new List&lt;SampleType&gt;(){ a, b, c } en C# ou Dim sampleList = { a, b, c } en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Boucle, telle que for ou while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Opération qui lit un champ ou une propriété, telle que obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Opération qui crée un objet et initialise un ou plusieurs de ses membres, telle que new Point { X = 1, Y = 2 } en C# ou New Point With {.X = 1, .Y = 2} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Opération arithmétique de reste, telle que (a % b) en C# ou (a Mod b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Opération arithmétique d'assignation composée du reste, telle que (a %= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Opération de multiplication, telle que (a * b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Opération d'assignation composée de multiplication, telle que (a *= b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Opération d'assignation composée de multiplication, telle que (a *= b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Opération de multiplication, telle que (a * b), avec contrôle de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Opération arithmétique de négation, telle que (-a).L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Opération arithmétique de négation, telle que (-a), avec contrôle de dépassement.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Opération qui appelle un constructeur pour créer un nouvel objet, telle que new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Opération qui crée un nouveau tableau dans lequel les limites de chaque dimension sont spécifiées, telle que new SampleType[dim1, dim2] en C# ou New SampleType(dim1, dim2) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Opération qui crée un nouveau tableau unidimensionnel et à l'initialise à partir d'une liste d'éléments, telle que new SampleType[]{a, b, c} en C# ou New SampleType(){a, b, c} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Complément de bits ou opération de négation logique.En C#, équivaut à (~a) pour les types intégraux et à (!a) pour les valeurs booléennes.En Visual Basic, équivaut à (Not a).L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparaison d'inégalité, telle que (a != b) en C# ou (a &lt;&gt; b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Opération de complément, telle que (~a) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Opération OR au niveau du bit ou logique, telle que (a | b) en C# ou (a Or b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Assignation composée OR au niveau du bit ou logique, telle que (a |= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Opération OR conditionnelle de court-circuit, telle que (a || b) en C# ou (a OrElse b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Référence à un paramètre ou une variable défini(e) dans le contexte de l'expression.Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Décrément suffixé unaire, tel que (a--).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Incrément suffixé unaire, tel que (a++).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Opération mathématique qui élève un nombre à une puissance, telle que (a ^ b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Opération d'assignation composée qui élève un nombre à une puissance, telle que (a ^= b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Décrément préfixé unaire, tel que (--a).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Incrément préfixé unaire, tel que (++a).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expression comportant une valeur constante de type <see cref="T:System.Linq.Expressions.Expression" />.Un nœud <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> peut contenir les références aux paramètres définis dans le contexte de l'expression qu'il représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Opération de décalage vers la droite au niveau du bit, telle que (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Opération d'assignation composée de décalage vers la droite au niveau du bit, telle que (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Liste de variables d'exécution.Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Opération de soustraction, telle que (a - b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Opération d'assignation composée de soustraction, telle que (a -= b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Opération d'assignation composée de soustraction, telle que (a -= b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Opération de soustraction arithmétique, telle que (a - b), avec contrôle de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Opération de commutateur, telle que switch en C# ou Select Case en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Opération qui lève une exception, telle que throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expression try-catch.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Référence explicite ou conversion boxing dans laquelle la valeur null est fournie si la conversion échoue, telle que (obj as SampleType) en C# ou TryCast(obj, SampleType) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Test de type exact.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Test de type, tel que obj is SampleType en C# ou TypeOf obj is SampleType en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Opération plus unaire, telle que (+a).Le résultat d'une opération plus unaire prédéfinie est la valeur de l'opérande, mais les implémentations définies par l'utilisateur peuvent avoir des résultats inhabituels.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Opération de type valeur unbox, telle que les instructions unbox et unbox.any en MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Représente un visiteur ou un module de réécriture pour les arborescences d'expression.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Initialise une nouvelle instance d'<see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Distribue la liste des expressions à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <returns>Liste d'expressions modifiées, si l'un des éléments a été modifié ; sinon, retourne la liste d'expressions d'origine.</returns>
      <param name="nodes">Expressions à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visite tous les nœuds dans la collection à l'aide d'un visiteur d'élément spécifié.</summary>
      <returns>Liste de nœuds modifiés, si des éléments ont été modifiés ; sinon, retourne la liste de nœuds d'origine.</returns>
      <param name="nodes">Nœuds à visiter.</param>
      <param name="elementVisitor">Délégué qui visite un élément unique, éventuellement le remplaçant par un nouvel élément.</param>
      <typeparam name="T">Type des nœuds.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Distribue l'expression à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="nodes">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visite les enfants de l'expression d'extension.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visite <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
      <typeparam name="T">Type du délégué.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Représente un saut inconditionnel.Cela inclut des instructions return, des instructions break et continue et d'autres sauts.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Type d'expression « go to ».Sert uniquement à des fins d'information.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> qui représente le type d'expression « go to ».</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Étiquette cible à laquelle ce nœud accède.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente l'étiquette cible pour ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> du résultat. </param>
      <param name="value">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> du résultat. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valeur passée à la cible, ou null si la cible est de type System.Void.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur passée à la cible ou null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Spécifie le type de saut que <see cref="T:System.Linq.Expressions.GotoExpression" /> représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut vers un emplacement.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Représente l'indexation d'une propriété ou d'un tableau.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</summary>
      <returns>Collection en lecture seule qui contient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtient le <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon retourne null.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objet à indexer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'objet à indexer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Représente une expression qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtient les arguments auxquels l'expression lambda ou le délégué est appliqué.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué est appliqué.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtient le délégué ou l'expression lambda à appliquer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué à appliquer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Représente une étiquette, qui peut être placée dans tout contexte <see cref="T:System.Linq.Expressions.Expression" />.En cas de saut à cette étiquette, elle a la valeur fournie par le <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondant.Sinon, elle reçoit la valeur indiquée dans <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Si <see cref="T:System.Type" /> est System.Void, aucune valeur ne doit être fournie.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>La valeur de <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via le flux de contrôle normal (par exemple, sans saut).</summary>
      <returns>Objet Expression représentant la valeur de <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> du résultat.</param>
      <param name="defaultValue">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilisé pour représenter la cible d'un <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtient le nom de l'étiquette.</summary>
      <returns>Nom de l'étiquette.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Type de valeur passée lors de l'accès à l'étiquette (ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée).</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type de la valeur passée lors de l'accès à l'étiquette ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Décrit une expression lambda.Capture un bloc de code semblable au corps d'une méthode .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtient le corps de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps de l'expression lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produit un délégué qui représente l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> qui contient la version compilée de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtient le nom de l'expression lambda.</summary>
      <returns>Nom de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtient les paramètres de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtient le type de retour de l'expression lambda.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtient la valeur qui indique si l'expression lambda doit être compilée avec l'optimisation d'appel tail.</summary>
      <returns>True si l'expression lambda doit être compilée avec l'optimisation d'appel tail, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Représente un appel de constructeur ayant un initialiseur de collection.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtient les initialiseurs de l'élément utilisés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> qui représentent les éléments utilisés pour initialiser la collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtient l'expression qui contient un appel au constructeur d'un type de collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel au constructeur d'un type de collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Réduit le nœud d'expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> du résultat.</param>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Représente une boucle infinie.Elle peut être quittée avec « break ».</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="breakLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> du résultat.</param>
      <param name="continueLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Représente l'opération d'assignation d'un champ ou d'une propriété à un objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtient l'expression à assigner au champ ou à la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur à assigner au champ ou à la propriété.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fournit la classe de base à partir de laquelle sont dérivées les classes qui représentent les liaisons utilisées pour initialiser les membres d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtient le type de liaison représenté.</summary>
      <returns>Une des valeurs de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtient le champ ou la propriété à initialiser.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété à initialiser.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Retourne une représentation textuelle du <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Représentation textuelle du <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Décrit les types de liaison utilisés dans les objets <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Liaison qui représente l'initialisation d'un membre avec la valeur d'une expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Liaison qui représente l'initialisation d'un membre de type <see cref="T:System.Collections.IList" /> ou <see cref="T:System.Collections.Generic.ICollection`1" /> dans une liste d'éléments.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Liaison qui représente l'initialisation récurrente des membres d'un membre.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Représente l'accès à un champ ou à une propriété.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtient l'objet contenant du champ ou de la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet contenant du champ ou de la propriété.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtient le champ ou la propriété auquel accéder.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété auquel accéder.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Retourne le type de nœud de ce <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Représente l'appel d'un constructeur et l'initialisation d'un ou de plusieurs membres du nouvel objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtient les liaisons qui décrivent comment initialiser les membres de l'objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtient l'expression qui représente l'appel de constructeur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Réduit <see cref="T:System.Linq.Expressions.MemberInitExpression" /> à une expression plus simple. </summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> du résultat.</param>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Représente l'initialisation des éléments d'un membre de collection d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtient les initialiseurs de l'élément pour initialiser un membre de collection d'un objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> avec lequel initialiser un membre de collection.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Représente l'initialisation des membres d'un membre d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtient les liaisons qui décrivent comment initialiser les membres d'un membre.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres du membre.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Représente un appel à une méthode statique ou une méthode d'instance.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtient une collection d'expressions qui représentent les arguments de la méthode appelée.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments de la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtient l'objet <see cref="T:System.Reflection.MethodInfo" /> pour la méthode à appeler.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtient l'objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'instance pour les appels de méthode d'instance ou null pour les appels de méthode statique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet de réception de la méthode.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Représente la création d'un tableau et l'éventuelle initialisation des éléments du nouveau tableau.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtient les limites du tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, ou les valeurs pour initialiser les éléments du nouveau tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les limites du tableau ou les valeurs d'initialisation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Représente un appel de constructeur.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtient les arguments du constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments du constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtient le constructeur appelé.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur appelé.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtient les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Reflection.MemberInfo" /> qui représentent les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Représente une expression de paramètre nommée.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indique que ParameterExpression doit être traité comme un paramètre ByRef.</summary>
      <returns>True si ParameterExpression est un paramètre ByRef, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtient le nom du paramètre ou de la variable.</summary>
      <returns>
        <see cref="T:System.String" /> qui contient le nom du paramètre.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expression qui fournit l'autorisation de lecture/écriture d'exécution pour les variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> du résultat.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables ou paramètres auxquels fournir l'accès d'exécution.</summary>
      <returns>Collection en lecture seule qui contient des paramètres qui se verront octroyer l'accès d'exécution.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Représente le cas d'un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtient le corps de ce cas.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps du bloc case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtient les valeurs de ce cas.Ce cas est sélectionné pour être exécuté lorsque le <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> correspond à chacune de ces valeurs.</summary>
      <returns>Collection en lecture seule des valeurs de ce bloc case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="testValues">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Représente une expression de contrôle qui gère des sélections multiples en transmettant le contrôle à <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtient la collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" /> pour le commutateur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtient la méthode de comparaison d'égalité, le cas échéant.</summary>
      <returns>Objet <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode de comparaison d'égalité.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="switchValue">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> du résultat.</param>
      <param name="cases">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> du résultat.</param>
      <param name="defaultBody">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Stocke les informations nécessaires pour émettre les informations de symboles de débogage pour un fichier source, en particulier le nom de fichier et l'identificateur de langue unique.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Retourne l'identificateur unique du type de document, le cas échéant.La valeur par défaut est le GUID pour un fichier texte.</summary>
      <returns>Identificateur unique du type de document.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nom du fichier source.</summary>
      <returns>Chaîne représentant le nom du fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Retourne l'identificateur unique de langue, le cas échéant.</summary>
      <returns>Identificateur unique de langue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Retourne l'identificateur unique du fournisseur de langue, le cas échéant.</summary>
      <returns>Identificateur unique du fournisseur de langue.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Représente un bloc try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtient la collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</summary>
      <returns>Collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Body" /> du résultat.</param>
      <param name="handlers">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> du résultat.</param>
      <param name="finally">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> du résultat.</param>
      <param name="fault">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Représente une opération entre une expression et un type.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtient l'opérande d'expression d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande d'expression d'une opération de test de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtient l'opérande de type d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente l'opérande de type d'une opération de test de type.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Représente une expression qui comporte un opérateur unaire.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si un nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns>true si le nœud représente un appel levé ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>true si le type de retour de l'opérateur est levé vers un type nullable ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtient la méthode d'implémentation pour l'opération unaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtient l'opérande de l'opération unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande de l'opération unaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Réduit le nœud d'expression en une expression plus simple. </summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="operand">Propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> du résultat.</param>
    </member>
  </members>
</doc>