<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <typeparam name="T">Tipo del contenido del origen de datos.Este parámetro de tipo es covariante. Es decir, puede usar el tipo especificado o cualquier tipo que sea más derivado. Para obtener más información sobre la covarianza y la contravarianza, consulte Covarianza y contravarianza en genéricos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se especifica el tipo de los datos.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtiene el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a este objeto.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtiene el árbol de expresión que está asociado a la instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que está asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtiene el proveedor de consultas que está asociado a este origen de datos.</summary>
      <returns>El objeto <see cref="T:System.Linq.IQueryProvider" /> que está asociado a este origen de datos.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se conoce el tipo de los datos.</summary>
      <typeparam name="T">El tipo de los datos del origen de datos.Este parámetro de tipo es covariante. Es decir, puede usar el tipo especificado o cualquier tipo que sea más derivado. Para obtener más información sobre la covarianza y la contravarianza, consulte Covarianza y contravarianza en genéricos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Define los métodos para crear y ejecutar las consultas descritas por un objeto <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TElement">Tipo de los elementos del objeto <see cref="T:System.Linq.IQueryable`1" /> que se devuelve.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta fuertemente tipada representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TResult">Tipo del valor que es el resultado de ejecutar la consulta.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Representa una expresión que tiene un operador binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo del árbol de expresión; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtiene la función de conversión de tipos utilizada por una operación de uso combinado o una operación de asignación compuesta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa un tipo de función de conversión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es true si el nodo representa una llamada elevada; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores NULL.</summary>
      <returns>Es true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtiene el operando izquierdo de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo de la operación binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación binaria.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtiene el operando derecho de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho de la operación binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="left">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del resultado. </param>
      <param name="conversion">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del resultado.</param>
      <param name="right">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Representa un bloque que contiene una secuencia de expresiones donde se pueden definir variables.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtiene las expresiones de este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las expresiones de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtiene la última expresión de este bloque.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la última expresión de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del resultado. </param>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtiene las variables definidas en este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las variables definidas en este bloque.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Representa una instrucción catch en un bloque try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtiene el cuerpo del bloque catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtiene el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtiene el tipo de <see cref="T:System.Exception" /> que este controlador captura.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de <see cref="T:System.Exception" /> que este controlador captura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variable">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del resultado.</param>
      <param name="filter">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtiene una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Representa una expresión que tiene un operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtiene la prueba de la operación condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba de la operación condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="test">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del resultado.</param>
      <param name="ifTrue">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del resultado.</param>
      <param name="ifFalse">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Representa una expresión que tiene un valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtiene el valor de la expresión constante.</summary>
      <returns>
        <see cref="T:System.Object" /> igual al valor de la expresión representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Emite o borra un punto de secuencia para obtener información de depuración.Esto permite al depurador resaltar el código fuente correcto al depurar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de código fuente.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtiene la columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtiene la línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtiene el valor para indicar si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se utiliza para borrar un punto de secuencia.</summary>
      <returns>Es true si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se va a utilizar para borrar un punto de secuencia; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtiene la columna inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtiene la línea inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Representa el valor predeterminado de un tipo o una expresión vacía.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Representa un inicializador para un elemento único de una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtiene el método de instancia que se utiliza para agregar un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Un <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtiene la colección de argumentos que se pasan a un método que agrega un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para un método que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Devuelve una representación textual de un objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Devuelve una representación textual del objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Proporciona la clase base de la que se derivan las clases que representan los nodos de árbol de expresión.También contiene métodos de generador static (Shared en Visual Basic) para crear los diversos tipos de nodo.Esta es una clase abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND condicional que evalúa el segundo operando solo si el primer operando se resuelve como true.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="method" /> es null y <paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz multidimensional.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="array">Expresión que representa la matriz multidimensional.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene expresiones usadas para indexar la matriz.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="array">Expresión que representa la matriz para indizar.</param>
      <param name="indexes">Matriz que contiene expresiones usadas para indizar la matriz.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz cuyo rango es mayor que uno.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="indexes" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bienEl rango de <paramref name="array" />. Tipo no coincide con el número de elementos de <paramref name="indexes" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="indexes" /> no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz de rango uno.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="index" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bien<paramref name="array" />. Tipo representa un tipo de matriz cuyo rango no es 1.O bien<paramref name="index" />. Type no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz multidimensional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="array">Matriz de instancias o índices <see cref="T:System.Linq.Expressions.Expression" /> para la operación de índice de matriz.</param>
      <param name="indexes">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="indexes" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bienEl rango de <paramref name="array" />. Tipo no coincide con el número de elementos de <paramref name="indexes" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="indexes" /> no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión para obtener la longitud de una matriz unidimensional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> es <paramref name="array" />.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienLa propiedad representada por <paramref name="member" /> no tiene un set descriptor de acceso.O bien<paramref name="expression" />. Tipo no es asignable al tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un miembro mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establece en <paramref name="expression" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienLa propiedad accede <paramref name="propertyAccessor" /> no tiene un set descriptor de acceso.O bien<paramref name="expression" />. Tipo no es asignable al tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene dos expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene tres expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cuatro expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cinco expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
      <param name="arg4">Quinta expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" />.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que no toma ningún argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="instance">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> (pase null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.O bienEl número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma dos argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia.(Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma tres argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia.(Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.O bien<paramref name="arguments" /> no es null y uno o varios de sus elementos están null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.O bienEl número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> es <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de instancia especificado y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> en cuyo valor de propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se buscará un método específico.</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="instance" /> o <paramref name="methodName" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="instance" />. Tipo o sus tipos base.O bienMás de un método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="instance" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático (Shared en Visual Basic).</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arguments">Colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos de llamada.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) que toma un argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma dos argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma tres argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cuatro argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cinco argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el quinto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) que tiene argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método static (Shared en Visual Basic) en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método static especificado (Shared en Visual Basic) y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo que contiene el método static especificado (Shared en Visual Basic).</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="methodName" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="type" /> o sus tipos base.O bienMás de un método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="type" /> o sus tipos base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica que el nodo se puede reducir a uno más simple.Si devuelve true, se puede llamar a Reduce() para generar el formulario reducido.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con una referencia al objeto <see cref="T:System.Exception" /> detectado para su uso en el cuerpo del controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> y una referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> pero sin ninguna referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> no representa un tipo de referencia o un tipo de valor que aceptan valores NULL.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />. Tipo y <paramref name="right" />. El tipo no son convertibles entre sí.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión, dada una función de conversión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />. Tipo y <paramref name="right" />. El tipo no son convertibles entre sí.O bien<paramref name="conversion" /> no es null y <paramref name="conversion" />. Tipo es un tipo de delegado que no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> no representa un tipo de referencia o un tipo de valor que aceptan valores NULL.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> representa un tipo que no se puede asignar al tipo de parámetro del tipo delegado <paramref name="conversion" />. Tipo.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="right" /> no es igual que el tipo de valor devuelto del tipo delegado <paramref name="conversion" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> o <paramref name="ifTrue" /> o <paramref name="ifFalse" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />. El tipo no es <see cref="T:System.Boolean" />.O bien<paramref name="ifTrue" />. Tipo no es igual a <paramref name="ifFalse" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> establecida en el valor especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> se establece en el valor especificado.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> establecidas en los valores especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> no es null y <paramref name="type" /> no es asignable desde el tipo dinámico de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión de tipos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión para la que se especifica el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.O bien<paramref name="expression" />. Tipo no es asignable al tipo de argumento del método representado por <paramref name="method" />.O bienEl tipo de valor devuelto del método representado por <paramref name="method" /> no es asignable al <paramref name="type" />.O bien<paramref name="expression" />. Tipo o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor no acepta valores NULL correspondiente no es el tipo de argumento o tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método que coincide con el <paramref name="method" /> se encontró la descripción.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si el tipo de destino está desbordado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si el tipo de destino está desbordado y para la que se especifica el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.O bien<paramref name="expression" />. Tipo no es asignable al tipo de argumento del método representado por <paramref name="method" />.O bienEl tipo de valor devuelto del método representado por <paramref name="method" /> no es asignable al <paramref name="type" />.O bien<paramref name="expression" />. Tipo o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor no acepta valores NULL correspondiente no es el tipo de argumento o tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método que coincide con el <paramref name="method" /> se encontró la descripción.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con el intervalo especificado.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <param name="startLine">Línea de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="startColumn">Columna de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="endLine">Línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor o igual que la línea de inicio.</param>
      <param name="endColumn">Columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la línea de fin es igual que la de inicio, debe ser mayor o igual que la columna de inicio.En cualquier caso, debe ser mayor que 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en el tipo especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de división no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de división no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dado un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> como segundo argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que <paramref name="addMethod" /> representa no se denomina "Add" (con distinción entre mayúsculas y minúsculas).O bienEl método que <paramref name="addMethod" /> representa no es un método de instancia.O bien<paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del método que <paramref name="addMethod" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dada una matriz de valores como segundo argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que addMethod representa no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).O bienEl método que addMethod representa no es un método de instancia.O bienEl parámetro arguments no contiene el mismo número de elementos que el número de parámetros del método que addMethod representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea una expresión vacía que tiene el tipo <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de igualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de igualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El XOR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y la XOR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Para static (Shared en Visual Basic), <paramref name="expression" /> debe ser null.</param>
      <param name="field">Objeto <see cref="T:System.Reflection.FieldInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="field" /> es null.O bienEl campo representado por <paramref name="field" /> no static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo del campo representado por <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo dado el nombre del campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo denotado por <paramref name="fieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo llamado <paramref name="fieldName" />.Este puede ser null para los campos estáticos.</param>
      <param name="fieldName">Nombre de un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="fieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ningún campo denominado <paramref name="fieldName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor del campo.Este puede ser null para los campos estáticos.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene el campo.</param>
      <param name="fieldName">Campo al que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un objeto <see cref="T:System.Type" /> que representa un tipo de delegado System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>Tipo de un delegado System.Action que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de hasta dieciséis objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene más de dieciséis elementos.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtiene un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func o System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>Tipo de delegado.</returns>
      <param name="typeArgs">Argumentos de tipo del delegado.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>Tipo de un delegado System.Func que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de entre uno y diecisiete objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene menos de uno o más de diecisiete elementos.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "mayor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "mayor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "mayor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "mayor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con una instrucción if.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> se establecen en los valores especificados.La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establece en la expresión predeterminada y el tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con instrucciones if y else.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.El tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento del valor de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda a los que se aplicará.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Type no representa un tipo de delegado o un <see cref="T:System.Linq.Expressions.Expression`1" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda que se aplicará.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Type no representa un tipo de delegado o un <see cref="T:System.Linq.Expressions.Expression`1" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y sin nombre.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta sin un valor predeterminado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sin un valor predeterminado.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta con el valor predeterminado dado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> con el valor predeterminado dado.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valor de este objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se alcanza la etiqueta mediante el flujo de control regular.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y con el nombre dado.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo dado.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre dados.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene más de dieciséis elementos.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> que representa una firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> que representa una firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />. </param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada. </param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desplazamiento a la izquierda no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desplazamiento a la izquierda no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "menor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "menor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "menor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "menor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad que representa el método <paramref name="propertyAccessor" /> accesos no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad que representa el método <paramref name="propertyAccessor" /> accesos no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) declarados en <paramref name="newExpression" />. Type o su tipo base.O bienEl método add en <paramref name="newExpression" />. Type o su tipo base no toma exactamente un argumento.O bienEl tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método add en <paramref name="newExpression" />. Type o su tipo base.O bienExiste más de un método de compatible con los argumentos denominado "Add" (entre mayúsculas y minúsculas) en <paramref name="newExpression" />. Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) declarados en <paramref name="newExpression" />. Type o su tipo base.O bienEl método add en <paramref name="newExpression" />. Type o su tipo base no toma exactamente un argumento.O bienEl tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método add en <paramref name="newExpression" />. Type o su tipo base.O bienExiste más de un método de compatible con los argumentos denominado "Add" (entre mayúsculas y minúsculas) en <paramref name="newExpression" />. Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia llamado "Add" (no distingue entre mayúsculas y minúsculas) que agrega un elemento a una colección.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.O bien<paramref name="addMethod" /> no es null y no representa un método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.O bien<paramref name="addMethod" /> no es null y el tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="initializers" /> no es asignable al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y no existe ningún método de instancia denominado "Add" que toma un argumento de tipo compatible en <paramref name="newExpression" />. Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que toma un argumento que agrega un elemento a una colección.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.O bien<paramref name="addMethod" /> no es null y no representa un método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.O bien<paramref name="addMethod" /> no es null y el tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="initializers" /> no es asignable al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y no existe ningún método de instancia denominado "Add" que toma un argumento de tipo compatible en <paramref name="newExpression" />. Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado y el destino Break.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
      <param name="continue">Destino Continue empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados los operandos izquierdo y derecho, llamando a un método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho y el método de implementación, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho, el método de implementación y la función de conversión de tipos, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa una función de conversión de tipos.Este parámetro solo se usa si <paramref name="binaryType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o una asignación compuesta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto al objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado.Además se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> del objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada en un objeto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Debe ser null si la propiedad es static (shared en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) que contiene los argumentos que se usarán para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo o a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto al que pertenece el miembro.Puede ser null para los miembros estáticos.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que describe el campo o la propiedad a los que se va a tener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="type">Tipo de resultado de la expresión try.Si es null, el cuerpo y todos los controladores deben tener un tipo idéntico.</param>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.Pasa null si el bloque try no tiene ningún bloque finally asociado.</param>
      <param name="fault">Cuerpo del bloque fault.Pasa null si el bloque try no tiene ningún bloque fault asociado.</param>
      <param name="handlers">Colección de objetos <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado un operando, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase null si no es aplicable).</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no se corresponde con un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dados un operando y un método de implementación, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase null si no es aplicable).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no se corresponde con un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de la propiedad que se tiene acceso mediante el método que <paramref name="propertyAccessor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de la propiedad que se tiene acceso mediante el método que <paramref name="propertyAccessor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo que <paramref name="newExpression" />. Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo que <paramref name="newExpression" />. Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de módulo no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de módulo no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador unario menos para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador unario menos para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador unario menos para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador unario menos para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado que no toma ningún argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el valor especificado.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El constructor que <paramref name="constructor" /> representa tiene al menos un parámetro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.Se especifican los miembros que obtienen acceso a los campos inicializados por el constructor.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Reflection.MemberInfo" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.O bienUn elemento de <paramref name="members" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.O bienEl <paramref name="members" /> parámetro no tiene el mismo número de elementos como <paramref name="arguments" />.O bienUn elemento de <paramref name="arguments" /> tiene un <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.Los miembros que obtienen acceso a los campos inicializados por el constructor se especifican como una matriz.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.O bienUn elemento de <paramref name="members" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.O bienEl <paramref name="members" /> parámetro no tiene el mismo número de elementos como <paramref name="arguments" />.O bienUn elemento de <paramref name="arguments" /> tiene un <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="arguments" /> coincide con el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor sin parámetros del tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor sin parámetros del tipo especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que tiene un constructor que no toma ningún argumento.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El tipo que <paramref name="type" /> representa no tiene un constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="bounds" /> es null.O bienUn elemento de <paramref name="bounds" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="bounds" /> no representa un tipo integral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="bounds" /> es null.O bienUn elemento de <paramref name="bounds" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="bounds" /> no representa un tipo integral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="initializers" /> es null.O bienUn elemento de <paramref name="initializers" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="initializers" /> representa un tipo que no es asignable al tipo que <paramref name="type" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="initializers" /> es null.O bienUn elemento de <paramref name="initializers" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="initializers" /> representa un tipo que no se puede asignar al tipo <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtiene el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador unario not no está definido para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador unario not no está definido para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desigualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desigualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="method" /> es null y <paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> se establecen en los valores especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o variable; se emplea solo para depurar o imprimir.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de exponenciación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo o <paramref name="right" />. El tipo no son <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de exponenciación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="method" /> es null y <paramref name="left" />. Tipo o <paramref name="right" />. El tipo no son <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad usando un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Puede ser null para las propiedades estáticas.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null.O bienEl método que <paramref name="propertyAccessor" /> representa no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="propertyAccessor" />.O bienEl método que <paramref name="propertyAccessor" /> representa no es un método de descriptor de acceso de propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Puede ser null para las propiedades estáticas.</param>
      <param name="property">Objeto <see cref="T:System.Reflection.PropertyInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="property" /> es null.O bienLa propiedad que <paramref name="property" /> representa no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo de la propiedad que <paramref name="property" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad denotada por <paramref name="propertyName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad llamada <paramref name="propertyName" />.Puede ser null para las propiedades estáticas.</param>
      <param name="propertyName">Nombre de una propiedad a la que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="propertyName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ninguna propiedad denominada <paramref name="propertyName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="propertyName">Nombre del indizador.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que obtiene acceso a una propiedad.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor de la propiedad.Puede ser null para las propiedades estáticas.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene la propiedad.</param>
      <param name="propertyName">Propiedad a la que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad o a un campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> o <see cref="T:System.Reflection.FieldInfo" /> que representa la propiedad o el campo denotados por <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad o un campo llamados <paramref name="propertyOrFieldName" />.Puede ser null para los miembros estáticos.</param>
      <param name="propertyOrFieldName">Nombre de una propiedad o un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ninguna propiedad o campo denominado <paramref name="propertyOrFieldName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión que tiene un valor de tipo <see cref="T:System.Linq.Expressions.Expression" /> constante.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduce este nodo a una expresión más simple.Si CanReduce devuelve true, debería devolver una expresión válida.Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduce este nodo a una expresión más simple.Si CanReduce devuelve true, debería devolver una expresión válida.Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduce la expresión a un tipo de nodo conocido (no es un nodo de extensión) o, si ya es un tipo conocido, solo devuelve la expresión.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad de referencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad de referencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción con un tipo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</returns>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desplazamiento a la derecha no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desplazamiento a la derecha no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</returns>
      <param name="variables">Colección de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</returns>
      <param name="variables">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch sin un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> para usarlo en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> establecida en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción con un tipo dado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y ningún bloque fault o finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y un bloque finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque fault y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="fault">Cuerpo del bloque fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque finally con un bloque fault y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>true si el tipo de delegado System.Action genérico se creó para el objeto <paramref name="typeArgs" /> específico; en caso contrario, false.</returns>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Action.</param>
      <param name="actionType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Action con argumentos de tipo concretos.Contiene null si no hay ningún delegado System.Action genérico que coincida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>true si el tipo de delegado System.Func genérico se creó para el objeto <paramref name="typeArgs" /> específico; en caso contrario, false.</returns>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Func.</param>
      <param name="funcType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Func con argumentos de tipo concretos.Contiene null si no hay ningún delegado System.Func genérico que coincida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="T:System.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una referencia explícita o conversión boxing donde se suministra null si se produce un error de conversión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara la identidad de tipo en tiempo de ejecución.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> y cuyas propiedades <see cref="T:System.Linq.Expressions.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador unario no está definido para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador unario no está definido para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una conversión unboxing explícita.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se va a aplicar la conversión unboxing.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o la variable.Este nombre se emplea únicamente para depurar o imprimir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduce el nodo y, a continuación, llama al delegado del visitante en la expresión reducida.El método inicia una excepción si el nodo no es reducible.</summary>
      <returns>Expresión que se está visitando o una expresión que debería sustituirla en el árbol.</returns>
      <param name="visitor">Instancia de <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Representa una expresión lambda fuertemente tipada como una estructura de datos en el formato de árbol de expresión.Esta clase no puede heredarse.</summary>
      <typeparam name="TDelegate">Tipo de delegado que <see cref="T:System.Linq.Expressions.Expression`1" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila la expresión lambda descrita por el árbol de la expresión en el código ejecutable y genera un delegado que representa la expresión lambda.</summary>
      <returns>Un delegado de tipo <paramref name="TDelegate" /> que representa la expresión lambda compilada descrita por <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del resultado.</param>
      <param name="parameters">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Describe los tipos de nodo para los nodos de un árbol de expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Operación de suma, como a + b, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Operación de asignación compuesta de suma, como (a += b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Operación de asignación compuesta de suma, como (a += b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Operación de suma, como (a + b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Operación AND bit a bit o lógica, como (a &amp; b) en C# y (a And b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Representa una operación AND condicional que evalúa el segundo operando solo si el primer operando se evalúa como true.Corresponde a (a &amp;&amp; b) en C# y a (a AndAlso b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Operación de asignación compuesta AND bit a bit o lógica, como (a &amp;= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Representa una operación de indización en una matriz unidimensional, como array[index] en C# o array(index) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Operación que obtiene la longitud de una matriz unidimensional, como array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Operación de asignación, como (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Representa un bloque de expresiones.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Llamada de método, como en la expresión obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nodo que representa una operación de uso combinado de Null, como (a ?? b) en C# o If(a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Operación condicional, como a &gt; b ? a : b en C# o If(a &gt; b, a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Representa un valor constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Operación de conversión, como (SampleType)obj en C#o CType(obj, SampleType) en Visual Basic.Para una conversión numérica, si el valor convertido es demasiado grande para el tipo de destino, no se produce ninguna excepción.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Operación de conversión, como (SampleType)obj en C#o CType(obj, SampleType) en Visual Basic.Para una conversión numérica, se produce una excepción si el valor convertido no se ajusta al tipo de destino.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Representa información de depuración.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Operación de decremento unario, como (a - 1) en C# y Visual Basic.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Representa un valor predeterminado.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Operación de división, como (a / b), para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Operación de asignación compuesta de división, como (a /= b), para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Representa una operación dinámica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nodo que representa una comparación de igualdad, como (a == b) en C# o (a = b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Operación XOR bit a bit o lógica, como (a ^ b) en C# o (a Xor b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Operación de asignación compuesta XOR bit a bit o lógica, como (a ^= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Representa una expresión de extensión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expresión "ir a", como goto Label en C# o GoTo Label en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparación "mayor que", como (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparación "mayor o igual que", como (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Operación de incremento unario, como (a + 1) en C# y Visual Basic.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Operación de índice u operación que tiene acceso a una propiedad que admite argumentos. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Operación que invoca un delegado o una expresión lambda, como sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valor de condición false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valor de condición true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Representa una etiqueta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Expresión lambda, como a =&gt; a + a en C# o Function(a) a + a en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Operación de desplazamiento a la izquierda bit a bit, como (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Asignación compuesta y desplazamiento a la izquierda bit a bit, como (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparación "menor que", como (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparación "menor o igual que", como (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Operación que crea un nuevo objeto <see cref="T:System.Collections.IEnumerable" /> y lo inicializa desde una lista de elementos, como new List&lt;SampleType&gt;(){ a, b, c } en C# o Dim sampleList = { a, b, c } en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Bucle, como for o while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Operación que realiza la lectura de un campo o una propiedad, como obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Operación que crea un nuevo objeto e inicializa uno o más de sus miembros, como new Point { X = 1, Y = 2 } en C# o New Point With {.X = 1, .Y = 2} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Operación de resto aritmético, como (a % b) en C# o (a Mod b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Operación de asignación compuesta y resto aritmético, como (a %= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Operación de multiplicación, como (a * b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Operación de asignación compuesta de multiplicación, como (a *= b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Operación de asignación compuesta de multiplicación, como (a *= b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Operación de multiplicación, como (a * b), que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Operación de negación aritmética, como (-a).El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Operación de negación aritmética, como (-a), con comprobación de desbordamiento.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Operación que llama a un constructor para crear un nuevo objeto, como new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Operación que crea una nueva matriz en la que se especifican los límites de cada dimensión, como new SampleType[dim1, dim2] en C# o New SampleType(dim1, dim2) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Operación que crea una nueva matriz unidimensional y la inicializa a partir de una lista de elementos, como new SampleType[]{a, b, c} en C# o New SampleType(){a, b, c} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Representa una operación de complemento bit a bit o de negación lógica.En C#, su equivalente es (~a) para los tipos enteros y (!a) para los valores booleanos.En Visual Basic, su equivalente es (Not a).El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparación de desigualdad, como (a != b) en C# o (a &lt;&gt; b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Operación de complemento a unos, como (~a) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Operación OR bit a bit o lógica, como (a | b) en C# o (a Or b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Asignación compuesta OR bit a bit o lógica, como (a |= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Operación OR condicional de cortocircuito, como (a || b) en C# o (a OrElse b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Referencia a un parámetro o variable que se define en el contexto de la expresión.Para obtener más información, vea <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Postfijo de decremento unario, como (a--).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Postfijo de incremento unario, como (a++).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Operación matemática que eleva un número a una potencia, como (a ^ b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Operación de asignación compuesta que eleva un número a una potencia, como (a ^= b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Prefijo de decremento unario, como (--a).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Prefijo de incremento unario, como (++a).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />.Un nodo <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> puede contener referencias a parámetros definidos en el contexto de la expresión que representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Operación de desplazamiento a la derecha bit a bit, como (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Operación de asignación compuesta y desplazamiento a la derecha bit a bit, como (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Lista de variables en tiempo de ejecución.Para obtener más información, vea <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Operación de resta, como (a - b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Operación de asignación compuesta de resta, como (a -= b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Operación de asignación compuesta de resta, como (a -= b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Operación de resta aritmética, como (a - b), que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Operación de modificador, como switch en C# o Select Case en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Operación que inicia una excepción, como throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expresión try-catch</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Referencia explícita o una conversión boxing en la que se proporciona el valor null si se produce un error en la conversión, como (obj as SampleType) en C# o TryCast(obj, SampleType) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Representa una prueba para comprobar la exactitud del tipo.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Comprobación de tipo, como obj is SampleType en C# o TypeOf obj is SampleType en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Operación unaria +, como (+a).El resultado de una operación unaria + predefinida es el valor del operando, pero las implementaciones definidas por el usuario podrían tener resultados poco habituales.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Operación de conversión unboxing a un tipo de valor, como las instrucciones unbox.any y unbox en MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Representa un visitante o un objeto de reescritura de árboles de expresión.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Envía la lista de expresiones a uno de los métodos de visita más especializados de esta clase.</summary>
      <returns>Lista de expresiones modificada, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de expresiones original.</returns>
      <param name="nodes">Expresiones que se van a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita todos los nodos de la colección utilizando un visitante de elementos especificado.</summary>
      <returns>Lista de nodos modificados, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de nodos original.</returns>
      <param name="nodes">Nodos que se van a visitar.</param>
      <param name="elementVisitor">Delegado que visita un único elemento, reemplazándolo opcionalmente con un elemento nuevo.</param>
      <typeparam name="T">Tipo de los nodos.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Envía la expresión a uno de los métodos de visita más especializados de esta clase.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="nodes">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita los elementos secundarios de la expresión de extensión.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
      <typeparam name="T">Tipo de delegado.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Representa un salto incondicional.Esto incluye instrucciones return, break y continue, y otros saltos.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Tipo de la expresión "ir a".Solo tiene fines informativos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> que representa el tipo de la expresión "ir a".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Etiqueta de destino a donde salta este nodo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa la etiqueta de destino para este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del resultado. </param>
      <param name="value">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valor pasado al destino o null si el destino es de tipo System.Void.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor pasado al destino o null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Especifica qué tipo de salto representa esta clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto a alguna ubicación.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Representa la indización de una propiedad o una matriz.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtiene los argumentos que se utilizarán para indizar la propiedad o la matriz.</summary>
      <returns>Colección de solo lectura que contiene los argumentos que se utilizarán para indizar la propiedad o la matriz.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtiene la clase <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</summary>
      <returns>Clase <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objeto que se va a indizar.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto que se va a indizar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Representa una expresión que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtiene los argumentos a los que se aplica el delegado o la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtiene el delegado o la expresión lambda que se van a aplicar.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado que se va a aplicar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Representa una etiqueta, que se puede colocar en cualquier contexto de <see cref="T:System.Linq.Expressions.Expression" />.Si se salta a ella, obtendrá el valor proporcionado por la clase <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondiente.De lo contrario, recibe el valor de <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Si <see cref="T:System.Type" /> es igual a System.Void, no se debe proporcionar ningún valor.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Valor de <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se llega a la etiqueta mediante el flujo de control normal (por ejemplo, no se salta a ella).</summary>
      <returns>Objeto Expression que representa el valor de la clase <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del resultado.</param>
      <param name="defaultValue">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Se utiliza para representar el destino de una clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtiene el nombre de la etiqueta.</summary>
      <returns>Nombre de la etiqueta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Tipo de valor que se pasa al saltar a la etiqueta (o <see cref="T:System.Void" /> si no se debe pasar ningún valor).</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo del valor que se pasa al saltar a la etiqueta o <see cref="T:System.Void" /> si no se debe pasar ningún valor.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Describe una expresión lambda.Captura un bloque de código similar a un cuerpo de método de .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtiene el cuerpo de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de la expresión lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Genera un delegado que representa la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> que contiene la versión compilada de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtiene el nombre de la expresión lambda.</summary>
      <returns>Nombre de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtiene los parámetros de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa los parámetros de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtiene el tipo de valor devuelto de la expresión lambda.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtiene el valor que indica si la expresión lambda se compilará con la optimización de llamada de cola.</summary>
      <returns>Es true si la expresión lambda se compilará con la optimización de llamada de cola; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Representa una llamada a un constructor que tiene un inicializador de colección.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtiene los inicializadores de elementos que se utilizan para inicializar una colección.</summary>
      <returns>Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.ElementInit" /> que representan los elementos que se utilizan para inicializar la colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtiene la expresión que contiene una llamada al constructor de un tipo de colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor de un tipo de colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del resultado.</param>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Representa un bucle infinito.Se puede salir del mismo con "break".</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="breakLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del resultado.</param>
      <param name="continueLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Representa la operación de asignación de un campo o propiedad de un objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtiene la expresión que se asigna al campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor que se asigna al campo o propiedad.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Proporciona la clase base de la que derivan las clases que representan enlaces que se utilizan para inicializar miembros de un objeto recientemente creado.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtiene el tipo de enlace que se representa.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtiene el campo o la propiedad que se va a inicializar.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad que va a inicializarse.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Describe los tipos de enlace que se utilizan en objetos <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Un enlace que representa la inicialización de un miembro con el valor de una expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Un enlace que representa la inicialización de un miembro de tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> de una lista de elementos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Un enlace que representa la inicialización de forma recursiva de los miembros de un miembro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Representa el acceso a un campo o propiedad.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtiene el objeto contenedor del campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto contenedor del campo o propiedad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtiene el campo o la propiedad a los que se va a tener acceso.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad a los que se va a tener acceso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Representa la llamada a un constructor y la inicialización de uno o más miembros del nuevo objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros del objeto recientemente creado.</summary>
      <returns>Una colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtiene la expresión que representa la llamada al constructor.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Reduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del resultado.</param>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Representa la inicialización de los elementos de un miembro de colección de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtiene los inicializadores de elemento para inicializar un miembro de colección de un objeto que se acaba de crear.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> con que se inicializa un miembro de colección.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Representa la inicialización de los miembros de un miembro de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros de un miembro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros del miembro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Representa una llamada a un método estático o un método de instancia.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtiene una colección de expresiones que representan los argumentos del método invocado.</summary>
      <returns>Uno <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtiene el objeto <see cref="T:System.Reflection.MethodInfo" /> del método al que se va a llamar.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtiene el objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la instancia para llamadas a métodos de instancia o null para llamadas a métodos estáticos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto receptor del método.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Representa creando una nueva matriz y posiblemente inicializando los elementos de la nueva matriz.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtiene los límites de la matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, o los valores para inicializar los elementos de la nueva matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>Un objeto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los límites de la matriz o los valores de inicialización.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Representa una llamada de constructor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtiene los argumentos para el constructor.</summary>
      <returns>Una colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para el constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtiene el constructor al que se llama.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor al que se llama.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtiene los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</summary>
      <returns>Una colección de objetos <see cref="T:System.Reflection.MemberInfo" /> que representan los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Representa una expresión de parámetro con nombre.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica que esta clase ParameterExpression se va a tratar como un parámetro ByRef.</summary>
      <returns>Es true si este objeto ParameterExpression es un parámetro ByRef; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtiene el nombre del parámetro o variable.</summary>
      <returns>
        <see cref="T:System.String" />. que contiene el nombre del parámetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expresión que proporciona permiso de lectura y escritura en tiempo de ejecución para variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables o parámetros para los que se va a proporcionar acceso en tiempo de ejecución.</summary>
      <returns>Colección de solo lectura que contiene parámetros para los que se proporcionará acceso en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Representa un caso de una clase <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtiene el cuerpo de este caso.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque de casos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtiene los valores de este caso.Este caso se selecciona para su ejecución cuando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> coincide con cualquiera de estos valores.</summary>
      <returns>Colección de solo lectura de los valores para este bloque de casos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="testValues">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Representa una expresión de control que administra varias selecciones pasando el control a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtiene la colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> del modificador.</summary>
      <returns>La colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtiene el método de comparación de igualdad, si existe.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de comparación de igualdad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="switchValue">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del resultado.</param>
      <param name="cases">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del resultado.</param>
      <param name="defaultBody">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Almacena información necesaria para emitir información de símbolos de depuración para un archivo de código fuente, en particular el nombre de archivo y el identificador de idioma único.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Devuelve el identificador único del tipo de documento, si existe.Tiene como valor predeterminado el GUID para un archivo de texto.</summary>
      <returns>Identificador único del tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nombre del archivo de código fuente.</summary>
      <returns>Cadena que representa el nombre del archivo de código fuente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Devuelve el identificador único del idioma, si existe.</summary>
      <returns>Identificador único del idioma.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Devuelve el identificador único del proveedor de idioma, si existe.</summary>
      <returns>Identificador único del proveedor de idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Representa un bloque try/catch/finally/de errores.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtiene la colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</summary>
      <returns>Colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del resultado.</param>
      <param name="handlers">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del resultado.</param>
      <param name="finally">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del resultado.</param>
      <param name="fault">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Representa una operación entre una expresión y un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtiene el operando de la expresión de una operación de prueba de un tipo.</summary>
      <returns>Un objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la expresión de una operación de prueba de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtiene el operando de tipo de una operación de prueba de tipo.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el operando del tipo de una operación de prueba de tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Representa una expresión que tiene un operador unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir un nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es true si el nodo representa una llamada elevada; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns>Es true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación unaria.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtiene el operando de la operación unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la operación unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduce el nodo de expresión a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="operand">Propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del resultado.</param>
    </member>
  </members>
</doc>