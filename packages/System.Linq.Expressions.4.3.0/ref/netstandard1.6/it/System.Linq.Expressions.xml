<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Rappresenta il risultato dell'operazione di ordinamento.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Rappresenta il risultato dell'operazione di ordinamento.</summary>
      <typeparam name="T">Il tipo di contenuto dell’origine dati.Il parametro di questo tipo è covariante. Ciò significa che è possibile usare il tipo specificato o qualsiasi tipo più derivato. Per altre informazioni sulla covarianza e la controvarianza, vedere Covarianza e controvarianza nei generics.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fornisce funzionalità per valutare query in relazione a un'origine dati specifica in cui il tipo dei dati non è specificato.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Ottiene il tipo dell'elemento o degli elementi che sono restituiti quando la struttura ad albero dell'espressione associata a questa istanza di <see cref="T:System.Linq.IQueryable" /> è eseguita.</summary>
      <returns>Un <see cref="T:System.Type" /> che rappresenta il tipo dell’elemento o degli elementi che sono restituiti quando la struttura ad albero dell'espressione associata a questo oggetto è eseguita.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Ottiene la struttura ad albero dell'espressione associata all'istanza di <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> associato a questa istanza di <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Ottiene il provider della query associato all’origine dati.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.IQueryProvider" /> associato con l’origine dati.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fornisce funzionalità per valutare query in relazione a un'origine dati specifica in cui il tipo dei dati è conosciuto.</summary>
      <typeparam name="T">Tipo di dati nell’origine dati.Il parametro di questo tipo è covariante. Ciò significa che è possibile usare il tipo specificato o qualsiasi tipo più derivato. Per altre informazioni sulla covarianza e la controvarianza, vedere Covarianza e controvarianza nei generics.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Definisce metodi per creare ed eseguire query descritte da un oggetto <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Costruisce un oggetto <see cref="T:System.Linq.IQueryable`1" /> per valutare la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Un oggetto <see cref="T:System.Linq.IQueryable`1" /> per valutare la query rappresentata dalla struttura ad albero dell'espressione specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <typeparam name="TElement">Tipo degli elementi dell’oggetto restituito <see cref="T:System.Linq.IQueryable`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Costruisce un oggetto <see cref="T:System.Linq.IQueryable" /> per valutare la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> in grado di valutare la query rappresentata dall'albero delle espressioni specificato.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Esegue la query fortemente tipizzata rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Il valore che è il risultato dell'esecuzione della query specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <typeparam name="TResult">Il tipo di valore che è il risultato dell'esecuzione della query.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Esegue la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Il valore che è il risultato dell'esecuzione della query specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Rappresenta un'espressione che ha un operatore binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se la struttura ad albero dell'espressione può essere ridotta, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Ottiene la funzione di conversione del tipo utilizzata da un'operazione di assegnazione coalescing o composta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> che rappresenta una funzione di conversione di tipi.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore.</summary>
      <returns>true se il nodo rappresenta una chiamata elevata; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore il cui tipo restituito è elevato a un tipo nullable.</summary>
      <returns>true se il tipo restituito dell'operatore è elevato a un tipo nullable; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Ottiene l'operando sinistro dell'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro dell'operazione binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Ottiene il metodo di implementazione per l'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Riduce il nodo dell'espressione binaria a un'espressione più semplice.</summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Ottiene l'operando destro dell'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro dell'operazione binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="left">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del risultato. </param>
      <param name="conversion">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del risultato.</param>
      <param name="right">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del risultato. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Rappresenta un blocco che contiene una sequenza di espressioni dove possono essere definite le variabili.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Ottiene le espressioni in questo blocco.</summary>
      <returns>La raccolta di sola lettura che contiene tutte le espressioni in questo blocco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Ottiene l'ultima espressione in questo blocco.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'ultima espressione in questo blocco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variables">Proprietà <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del risultato. </param>
      <param name="expressions">Proprietà <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del risultato. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Ottiene le variabili definite in questo blocco.</summary>
      <returns>La raccolta di sola lettura che contiene tutte le variabili definite in questo blocco.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Rappresenta un'istruzione catch in un blocco try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Ottiene il corpo di questo blocco catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Ottiene il corpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Ottiene il tipo <see cref="T:System.Exception" /> che questo handler cattura.</summary>
      <returns>L'oggetto <see cref="T:System.Type" /> che rappresenta il tipo di <see cref="T:System.Exception" /> che questo handler cattura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variable">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del risultato.</param>
      <param name="filter">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del risultato.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Ottiene un riferimento all'oggetto <see cref="T:System.Exception" /> catturato da questo handler.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> catturato da questo handler.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Rappresenta un'espressione che ha un operatore condizionale.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Ottiene l'espressione da eseguire se il test restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'espressione da eseguire se il test è false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Ottiene l'espressione da eseguire se il test restituisce true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'espressione da eseguire se il test è true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Ottiene il test dell'operazione condizionale.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test dell'operazione condizionale.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="test">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del risultato.</param>
      <param name="ifTrue">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del risultato.</param>
      <param name="ifFalse">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Rappresenta un'espressione che ha un valore costante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Ottiene il valore dell'espressione costante.</summary>
      <returns>
        <see cref="T:System.Object" /> uguale al valore dell'espressione rappresentata.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Crea o cancella un punto di sequenza per le informazioni di debug,consentendo al debugger di evidenziare il codice sorgente corretto durante l'esecuzione del debug.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Ottiene la colonna finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della colonna finale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Ottiene la riga finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della riga finale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Ottiene il valore per indicare se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> è per la cancellazione di un punto di sequenza.</summary>
      <returns>Vero se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> è per la cancellazione di un punto di sequenza, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Ottiene la colonna iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della colonna iniziale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Ottiene la riga iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della riga iniziale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Rappresenta il valore predefinito di un tipo o un'espressione vuota.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Rappresenta un inizializzatore per un singolo elemento di una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Ottiene il metodo di istanza utilizzato per aggiungere un elemento a una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza che aggiunge un elemento a una raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Ottiene la raccolta di argomenti passati a un metodo che aggiunge un elemento a una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti di un metodo che aggiunge un elemento a una raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Restituisce una rappresentazione testuale di un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Rappresentazione testuale dell'oggetto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fornisce la classe di base dalla quale derivano le classi che rappresentano i nodi della struttura ad albero delle espressioni.Contiene anche metodi factory static (Shared in Visual Basic) per creare i vari di tipi di nodo.Questa è una classe abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Costruisce una nuova istanza di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che non ha il controllo dell'overflow.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che ha il controllo dell'overflow.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione AND bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore AND bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione AND bit per bit.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore AND bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione AND condizionale che valuta il secondo operando solo se il primo operando restituisce true.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore AND bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione AND condizionale che valuta il secondo operando solo se il primo operando viene risolto in true.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore AND bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="method" /> è null e <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> per accedere a una matrice multidimensionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="array">Espressione che rappresenta la matrice multidimensionale.</param>
      <param name="indexes">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente le espressioni usate per indicizzare la matrice.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> per accedere a una matrice.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="array">Espressione che rappresenta la matrice da indicizzare.</param>
      <param name="indexes">Matrice contenente le espressioni usate per indicizzare la matrice.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" />che rappresenta l'applicazione di un operatore di indice di matrice a una matrice con numero di dimensioni maggiore di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="array">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</param>
      <param name="indexes">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.-oppure-Il numero di dimensioni di <paramref name="array" />.Type non corrisponde al numero di elementi in <paramref name="indexes" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="indexes" /> non rappresenta il tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'applicazione di un operatore di indice di matrice a una matrice con numero di dimensioni pari a 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="array">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="index">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="index" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.-oppure-<paramref name="array" />.Type rappresenta un tipo matrice il cui numero di dimensioni non è pari a 1.-oppure-<paramref name="index" />.Type non rappresenta il tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta l'applicazione di un operatore di indice di matrice a una matrice multidimensionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="array">Matrice di istanze o indici di <see cref="T:System.Linq.Expressions.Expression" /> per l'operazione di indicizzazione delle matrici.</param>
      <param name="indexes">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.-oppure-Il numero di dimensioni di <paramref name="array" />.Type non corrisponde al numero di elementi in <paramref name="indexes" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="indexes" /> non rappresenta il tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'espressione per ottenere la lunghezza di una matrice unidimensionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è uguale a <paramref name="array" />.</returns>
      <param name="array">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> che rappresenta l'inizializzazione di un campo o di una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-La proprietà rappresentata da <paramref name="member" /> non dispone di una funzione di accesso set.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> che rappresenta l'inizializzazione di un membro usando un metodo della funzione di accesso alle proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> è impostata su <paramref name="expression" />.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-La proprietà a cui si accede con <paramref name="propertyAccessor" /> non dispone di una funzione di accesso set.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate e non ha variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene due espressioni e non dispone di variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene tre espressioni e non dispone di variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene quattro espressioni e non dispone di variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
      <param name="arg3">Quarta espressione nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene cinque espressioni e non dispone di variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
      <param name="arg3">Quarta espressione nel blocco.</param>
      <param name="arg4">Quinta espressione nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate e non ha variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate, non dispone di variabili e dispone del tipo di risultato specifico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate, non dispone di variabili e dispone del tipo di risultato specifico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break con il tipo specificato.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" />.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che non accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata a un metodo di istanza. Passare null per un metodo static (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.-oppure-<paramref name="instance" /> è null e <paramref name="method" /> rappresenta un metodo di istanza.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />. Passare null per un metodo static (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.-oppure-<paramref name="instance" /> è null e <paramref name="method" /> rappresenta un metodo di istanza.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.-oppure-Il numero di elementi in <paramref name="arguments" /> non è uguale al numero di parametri del metodo rappresentato da <paramref name="method" />.-oppure-Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta due argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata all'istanza.Passare Null per un metodo statico (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta tre argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata all'istanza.Passare Null per un metodo statico (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata a un metodo di istanza. Passare null per un metodo static (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.-oppure-<paramref name="instance" /> è null e <paramref name="method" /> rappresenta un metodo di istanza.-oppure-<paramref name="arguments" /> non è null e uno o più elementi relativi sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.-oppure-Il numero di elementi in <paramref name="arguments" /> non è uguale al numero di parametri del metodo rappresentato da <paramref name="method" />.-oppure-Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo tramite la chiamata al metodo factory appropriato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> è uguale a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> è impostata sull'oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di istanza specificato e il cui oggetto <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> è impostato sugli argomenti specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> nel cui valore della proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> verrà cercato un metodo specificato.</param>
      <param name="methodName">Nome del metodo.</param>
      <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che specificano i parametri di tipo del metodo generico.Questo argomento deve essere Null quando methodName specifica un metodo non generico.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta gli argomenti del metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> o <paramref name="methodName" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="instance" />.Type o nei relativi tipi di base.-oppure-Più di un metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="instance" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico (Shared in Visual Basic).</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arguments">Raccolta di <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta gli argomenti della chiamata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata al metodo static (Shared in Visual Basic) che accetta un argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta due argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta tre argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta quattro argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <param name="arg3">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quarto argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta cinque argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <param name="arg3">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quarto argomento.</param>
      <param name="arg4">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quinto argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo static (Shared in Visual Basic) con argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo static (Shared in Visual Basic) su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> non è uguale al numero di parametri del metodo rappresentato da <paramref name="method" />.-oppure-Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo static (Shared in Visual Basic) tramite la chiamata al metodo factory appropriato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> è impostata sull'oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo static (Shared in Visual Basic) specificato e la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> è impostata sugli argomenti specificati.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo che contiene il metodo static (Shared in Visual Basic) specificato.</param>
      <param name="methodName">Nome del metodo.</param>
      <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che specificano i parametri di tipo del metodo generico.Questo argomento deve essere Null quando methodName specifica un metodo non generico.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="methodName" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="type" /> o nei relativi tipi di base.-oppure-Più di un metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="type" /> o nei relativi tipi di base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica che il nodo può essere ridotto a un nodo più semplice.Se restituisce true, è possibile chiamare Reduce() per generare la forma ridotta.</summary>
      <returns>True se il nodo può essere ridotto; in caso contrario, false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato per l'uso nel corpo del gestore.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un filtro <see cref="T:System.Exception" /> e un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un filtro <see cref="T:System.Exception" /> ma nessun riferimento all'oggetto <see cref="T:System.Exception" /> intercettato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza.</returns>
      <param name="document">Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione coalescing.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> non rappresenta un tipo di riferimento o un tipo valore nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type non sono convertibili l'uno nell'altro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione coalescing, data una funzione di conversione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type non sono convertibili l'uno nell'altro.-oppure-<paramref name="conversion" /> non è null e <paramref name="conversion" />.Type è un tipo delegato che non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> non rappresenta un tipo di riferimento o un tipo valore nullable.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> rappresenta un tipo non assegnabile al tipo di parametro del tipo delegato <paramref name="conversion" />.Type.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="right" /> è diversa dal tipo restituito del tipo delegato <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un'istruzione condizionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="test" />, il parametro <paramref name="ifTrue" /> o il parametro <paramref name="ifFalse" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type non è <see cref="T:System.Boolean" />.-oppure-<paramref name="ifTrue" />.Type è diverso da <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un'istruzione condizionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> è impostata sul valore specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> è impostata sul valore specificato.</returns>
      <param name="value">Oggetto <see cref="T:System.Object" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> le cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="value">Oggetto <see cref="T:System.Object" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> non è null e <paramref name="type" /> non è assegnabile dal tipo dinamico di <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione continue.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione continue con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione di tipo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione per la quale è specificato il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.-oppure-Il tipo restituito del metodo rappresentato da <paramref name="method" /> non è assegnabile a <paramref name="type" />.-oppure-<paramref name="expression" />.Type o <paramref name="type" /> è un tipo valore nullable e il tipo valore non nullable corrispondente è diverso dal tipo di argomento o dal tipo restituito, rispettivamente, del metodo rappresentato da <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo che corrisponde alla descrizione di <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione che genera un'eccezione in caso di overflow del tipo di destinazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione che genera un'eccezione in caso di overflow del tipo di destinazione e per la quale è specificato il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.-oppure-Il tipo restituito del metodo rappresentato da <paramref name="method" /> non è assegnabile a <paramref name="type" />.-oppure-<paramref name="expression" />.Type o <paramref name="type" /> è un tipo valore nullable e il tipo valore non nullable corrispondente è diverso dal tipo di argomento o dal tipo restituito, rispettivamente, del metodo rappresentato da <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo che corrisponde alla descrizione di <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con l'intervallo specificato.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</param>
      <param name="startLine">Riga iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di 0.</param>
      <param name="startColumn">Colonna iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di 0.</param>
      <param name="endLine">Riga finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di o uguale alla riga iniziale.</param>
      <param name="endColumn">Colonna finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Se la riga finale corrisponde alla riga iniziale, deve essere maggiore di o uguale alla colonna iniziale.In qualsiasi caso, deve essere maggiore di 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta il decremento dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione decrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da decrementare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta il decremento dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione decrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da decrementare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata sul tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata sul tipo specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di divisione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di divisione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di divisione aritmetica.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di divisione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />, dato <see cref="T:System.Collections.Generic.IEnumerable`1" /> come secondo argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ElementInit" /> le cui proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> che contiene gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il metodo che <paramref name="addMethod" /> rappresenta non è denominato "Add" (senza distinzione tra maiuscole e minuscole).-oppure-Il metodo che <paramref name="addMethod" /> rappresenta non è un metodo di istanza.-oppure-Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri del metodo rappresentato da <paramref name="addMethod" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del metodo rappresentato da <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />, data una matrice di valori come secondo argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ElementInit" /> le cui proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il metodo che addMethod rappresenta non è denominato "Add" (senza distinzione tra maiuscole e minuscole).-oppure-Il metodo che addMethod rappresenta non è un metodo di istanza.-oppure-Il numero di elementi in arguments è diverso dal numero di parametri del metodo rappresentato da addMethod.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del metodo rappresentato da <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea un'espressione vuota di tipo <see cref="T:System.Void" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata su <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di uguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianza.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di uguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore XOR non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore XOR non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Per static (Shared in Visual Basic), <paramref name="expression" /> deve essere null.</param>
      <param name="field">Oggetto <see cref="T:System.Reflection.FieldInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> è null.-oppure-Il campo rappresentato da <paramref name="field" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante del campo rappresentato da <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo, dato il nome del campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.FieldInfo" /> che rappresenta il campo identificato da <paramref name="fieldName" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo denominato <paramref name="fieldName" />.Può essere Null per i campi statici.</param>
      <param name="fieldName">Nome di un campo a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="fieldName" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Nessun campo denominato <paramref name="fieldName" /> è definito in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> creato.</returns>
      <param name="expression">Oggetto contenitore del campo.Può essere Null per i campi statici.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che contiene il campo.</param>
      <param name="fieldName">Campo al quale accedere.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un oggetto <see cref="T:System.Type" /> che rappresenta un tipo delegato System.Action generico con argomenti di tipo specifici.</summary>
      <returns>Tipo di un delegato System.Action con argomenti di tipo specificati.</returns>
      <param name="typeArgs">Matrice costituita da zero a sedici oggetti <see cref="T:System.Type" /> che specificano gli argomenti di tipo per il tipo delegato System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene più di sedici elementi.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Ottiene un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Func o System.Action generico con argomenti di tipo specifici.</summary>
      <returns>Tipo di delegato.</returns>
      <param name="typeArgs">Argomenti di tipo del delegato.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Func generico con argomenti di tipo specifici.L'ultimo argomento di tipo specifica il tipo restituito del delegato creato.</summary>
      <returns>Tipo di un delegato System.Func con argomenti di tipo specificati.</returns>
      <param name="typeArgs">Matrice costituita da zero a diciassette oggetti <see cref="T:System.Type" /> che specificano gli argomenti di tipo per il tipo delegato System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene meno di uno o più di diciassette elementi.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata sul valore specificato e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to".Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to" con il tipo specificato.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to" con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata sul valore specificato, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore di".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "maggiore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore di".Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "maggiore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "maggiore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "maggiore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un blocco condizionale con un'istruzione if.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> sono impostate sui valori specificati.La proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> è impostata sull'espressione predefinita e il tipo dell'oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> risultante restituito da questo metodo è <see cref="T:System.Void" />.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un blocco condizionale con le istruzioni if e else.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.Il tipo dell'oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> risultante restituito da questo metodo è <see cref="T:System.Void" />.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'incremento del valore dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione incrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da incrementare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'incremento dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione incrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da incrementare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica un delegato o un'espressione lambda a un elenco di espressioni di argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica il delegato o l'espressione lambda specificata agli argomenti forniti.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato o l'espressione lambda da applicare.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato o l'espressione lambda.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non rappresenta un tipo delegato o <see cref="T:System.Linq.Expressions.Expression`1" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del delegato rappresentato da <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri elencato per il delegato rappresentato da <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica un delegato o un'espressione lambda a un elenco di espressioni di argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica il delegato o l'espressione lambda specificata agli argomenti forniti.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato o l'espressione lambda da applicare.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato o l'espressione lambda.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non rappresenta un tipo delegato o <see cref="T:System.Linq.Expressions.Expression`1" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del delegato rappresentato da <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri elencato per il delegato rappresentato da <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Restituisce un valore che indica se l'espressione restituisce false.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce un valore che indica se l'espressione restituisce false.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Restituisce un valore che indica se l'espressione restituisce true.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce un valore che indica se l'espressione restituisce true.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con tipo void e nessun nome.</summary>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> che rappresenta un'etichetta senza un valore predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> senza un valore predefinito.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale verrà associato questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> che rappresenta un'etichetta con il valore predefinito specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> con il valore predefinito specificato.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale verrà associato questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valore di questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> quando l'etichetta viene raggiunta tramite il normale flusso di controllo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con tipo void e il nome specificato.</summary>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Nome dell'etichetta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con il tipo specificato.</summary>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo di valore passato durante il passaggio all'etichetta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con il tipo e il nome specificati.</summary>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo di valore passato durante il passaggio all'etichetta.</param>
      <param name="name">Nome dell'etichetta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo delegato.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è null.-oppure-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> non è un tipo delegato.-oppure-<paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito di <paramref name="TDelegate" />.-oppure-Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per <paramref name="TDelegate" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente di <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo delegato.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è null.-oppure-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> non è un tipo delegato.-oppure-<paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito di <paramref name="TDelegate" />.-oppure-Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per <paramref name="TDelegate" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente di <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è null.-oppure-Uno o più elementi di <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene più di sedici elementi.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la generazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la creazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la creazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la generazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato.Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <returns>Oggetto che rappresenta un'espressione lambda la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="T:System.Type" /> che rappresenta una firma di delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> è null.-oppure-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> non rappresenta un tipo delegato.-oppure-<paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito del tipo delegato rappresentato da <paramref name="delegateType" />.-oppure-Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per il tipo delegato rappresentato da <paramref name="delegateType" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente del tipo di delegato rappresentato da <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato.Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <returns>Oggetto che rappresenta un'espressione lambda la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="T:System.Type" /> che rappresenta una firma di delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> è null.-oppure-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> non rappresenta un tipo delegato.-oppure-<paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito del tipo delegato rappresentato da <paramref name="delegateType" />.-oppure-Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per il tipo delegato rappresentato da <paramref name="delegateType" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente del tipo di delegato rappresentato da <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />. </param>
      <param name="name">Nome dell'espressione lambda.Usato per la creazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata. </param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la creazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di spostamento a sinistra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di spostamento a sinistra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore di".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "minore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore di".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "minore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "minore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "minore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> dove il membro è un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-<see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o della proprietà che <paramref name="member" /> rappresenta non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> dove il membro è un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-<see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o della proprietà che <paramref name="member" /> rappresenta non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basato su un metodo della funzione di accesso alle proprietà specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e il cui oggetto <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> è popolato con gli elementi di <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-<see cref="P:System.Reflection.PropertyInfo.PropertyType" /> della proprietà a cui accede il metodo rappresentato da <paramref name="propertyAccessor" /> non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basato su un metodo della funzione di accesso alle proprietà specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e il cui oggetto <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> è popolato con gli elementi di <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-<see cref="P:System.Reflection.PropertyInfo.PropertyType" /> della proprietà a cui accede il metodo rappresentato da <paramref name="propertyAccessor" /> non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> specificati per inizializzare una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo denominato "Add" per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) è dichiarato in <paramref name="newExpression" />.Type o nel relativo tipo di base.-oppure-Il metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base non accetta esattamente un argomento.-oppure-Il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> del primo elemento di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base.-oppure-Esiste più di un metodo denominato "Add" (senza distinzione tra maiuscole e minuscole) compatibile con l'argomento su <paramref name="newExpression" />.Type e/o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> specificati per inizializzare una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo denominato "Add" per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) è dichiarato in <paramref name="newExpression" />.Type o nel relativo tipo di base.-oppure-Il metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base non accetta esattamente un argomento.-oppure-Il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> del primo elemento di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base.-oppure-Esiste più di un metodo denominato "Add" (senza distinzione tra maiuscole e minuscole) compatibile con l'argomento su <paramref name="newExpression" />.Type e/o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo specificato per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che aggiunge un elemento a una raccolta.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.-oppure-<paramref name="addMethod" /> non è null e non rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che accetta esattamente un argomento.-oppure-<paramref name="addMethod" /> non è null e il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> è null e non esiste alcun metodo di istanza denominato "Add" che accetta un argomento compatibile con il tipo su <paramref name="newExpression" />.Type o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo specificato per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza che accetta un argomento e aggiunge un elemento a una raccolta.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.-oppure-<paramref name="addMethod" /> non è null e non rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che accetta esattamente un argomento.-oppure-<paramref name="addMethod" /> non è null e il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> è null e non esiste alcun metodo di istanza denominato "Add" che accetta un argomento compatibile con il tipo su <paramref name="newExpression" />.Type o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo e la destinazione di interruzione specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
      <param name="break">Destinazione di interruzione usata dal corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
      <param name="break">Destinazione di interruzione usata dal corpo del ciclo.</param>
      <param name="continue">Destinazione di continuazione usata dal corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro e il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che specifica il metodo di implementazione.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro, il metodo di implementazione e la funzione di conversione di tipi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che specifica il metodo di implementazione.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> che rappresenta una funzione di conversione di tipi.Questo parametro viene usato solo se <paramref name="binaryType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o assegnazione composta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con gli elementi specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un passaggio dell'oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> specificato.Anche il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> impostata su <paramref name="kind" />, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e con <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="kind">Oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> dell'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata in un oggetto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Deve essere Null se la proprietà è static (shared in Visual Basic).</param>
      <param name="indexer">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Interfaccia IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) in Visual Basic) contenente gli argomenti che verranno usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo o a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto a cui appartiene il membro.Può essere Null per i membri statici.</param>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che descrive il campo o la proprietà a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con gli elementi specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'espressione try.Se Null, il corpo e tutti i gestori devono disporre di tipo identico.</param>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.Passare Null se al blocco try non è associato alcun blocco finally.</param>
      <param name="fault">Corpo del blocco fault.Passare Null se al blocco try non è associato alcun blocco fault.</param>
      <param name="handlers">Raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> tramite la chiamata al metodo factory appropriato, dato un operando.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="unaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione unaria.</param>
      <param name="operand">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo in cui convertire (passare null se non applicabile).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> non corrisponde a un nodo di espressione unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> tramite la chiamata al metodo factory appropriato, dato un operando e il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="unaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione unaria.</param>
      <param name="operand">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo in cui convertire (passare null se non applicabile).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> non corrisponde a un nodo di espressione unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un membro a cui si accede usando un metodo della funzione di accesso della proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo della proprietà a cui si accede con il metodo che <paramref name="propertyAccessor" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un membro a cui si accede usando un metodo della funzione di accesso della proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo della proprietà a cui si accede con il metodo che <paramref name="propertyAccessor" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Rappresenta un'espressione che crea un nuovo oggetto e inizializza una proprietà dell'oggetto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo che <paramref name="newExpression" />.Type rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo che <paramref name="newExpression" />.Type rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di resto aritmetico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore modulo non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di resto aritmetico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore modulo non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore meno unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore meno unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore meno unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica che ha il controllo dell'overflow.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore meno unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato che non accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> è impostata sul valore specificato.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il costruttore che <paramref name="constructor" /> rappresenta ha almeno un parametro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.I membri che accedono ai campi inizializzati del costruttore sono specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Reflection.MemberInfo" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.-oppure-Un elemento di <paramref name="members" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.-oppure-Il numero di elementi nel parametro <paramref name="members" /> è diverso da quello in <paramref name="arguments" />.-oppure-La proprietà <paramref name="arguments" /> di un elemento di <see cref="P:System.Linq.Expressions.Expression.Type" /> rappresenta un tipo non assegnabile al tipo del membro rappresentato dall'elemento corrispondente di <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.I membri che accedono ai campi inizializzati del costruttore sono specificati come matrice.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.-oppure-Un elemento di <paramref name="members" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.-oppure-Il numero di elementi nel parametro <paramref name="members" /> è diverso da quello in <paramref name="arguments" />.-oppure-La proprietà <paramref name="arguments" /> di un elemento di <see cref="P:System.Linq.Expressions.Expression.Type" /> rappresenta un tipo non assegnabile al tipo del membro rappresentato dall'elemento corrispondente di <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="arguments" /> corrisponde al numero di parametri per il costruttore che <paramref name="constructor" /> rappresenta.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore senza parametri del tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> è impostata su <see cref="T:System.Reflection.ConstructorInfo" />, che rappresenta il costruttore senza parametri per il tipo specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> con un costruttore che non accetta argomenti.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il tipo rappresentato da <paramref name="type" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice con una classificazione specificata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="bounds">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> è null.-oppure-Un elemento di <paramref name="bounds" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="bounds" /> non rappresenta un tipo integrale.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice con una classificazione specificata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="bounds">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> è null.-oppure-Un elemento di <paramref name="bounds" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="bounds" /> non rappresenta un tipo integrale.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice unidimensionale e la relativa inizializzazione da un elenco di elementi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> è null.-oppure-Un elemento di <paramref name="initializers" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="initializers" /> rappresenta un tipo non assegnabile al tipo rappresentato da <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice unidimensionale e la relativa inizializzazione da un elenco di elementi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> è null.-oppure-Un elemento di <paramref name="initializers" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="initializers" /> rappresenta un tipo non assegnabile al tipo <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Ottiene il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno dei valori di <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di complemento bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore Not unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di complemento bit per bit.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore Not unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di disuguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di disuguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Restituisce l'espressione che rappresenta il complemento a uno.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce l'espressione che rappresenta il complemento a uno.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR condizionale che valuta il secondo operando solo se il primo operando restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR condizionale che valuta il secondo operando solo se il primo operando restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="method" /> è null e <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati.</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e le cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> sono impostate sui valori specificati.</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
      <param name="name">Nome del parametro o della variabile, usato solo a scopo di debug o di stampa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo decremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo decremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo incremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo incremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un numero a una potenza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di elevamento a potenza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="left" />.Type e/o <paramref name="right" />.Type non sono <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un numero a una potenza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di elevamento a potenza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="method" /> è null e <paramref name="left" />.Type e/o <paramref name="right" />.Type non sono <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che decrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che decrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che incrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che incrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà tramite un metodo della funzione di accesso alle proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" />, che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Può essere Null per le proprietà statiche.</param>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null.-oppure-Il metodo rappresentato da <paramref name="propertyAccessor" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="propertyAccessor" />.-oppure-Il metodo rappresentato da <paramref name="propertyAccessor" /> non è un metodo della funzione di accesso alle proprietà.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Può essere Null per le proprietà statiche.</param>
      <param name="property">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> è null.-oppure-La proprietà rappresentata da <paramref name="property" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante della proprietà che <paramref name="property" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="indexer">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Raccolta <see cref="T:System.Collections.Generic.IEnumerable`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="indexer">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" />, che rappresenta la proprietà identificata da <paramref name="propertyName" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una proprietà denominata <paramref name="propertyName" />.Può essere null per le proprietà statiche.</param>
      <param name="propertyName">Nome di una proprietà a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyName" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Nessuna proprietà denominata <paramref name="propertyName" /> è definita in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="propertyName">Nome dell'indicizzatore.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che accede a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> creato.</returns>
      <param name="expression">Oggetto contenitore della proprietà.Può essere Null per le proprietà statiche.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che contiene la proprietà.</param>
      <param name="propertyName">Proprietà a cui accedere.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà o un campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" /> o su <see cref="T:System.Reflection.FieldInfo" />, che rappresenta la proprietà o il campo identificato da <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una proprietà o un campo denominato <paramref name="propertyOrFieldName" />.Può essere Null per i membri statici.</param>
      <param name="propertyOrFieldName">Nome di una proprietà o di un campo a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Nessuna proprietà o campo denominato <paramref name="propertyOrFieldName" /> è definito in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'espressione che ha un valore costante di tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Riduce questo nodo a un'espressione più semplice.Se CanReduce restituisce true, deve essere restituita un'espressione valida.Questo metodo può restituire un altro nodo che deve essere a sua volta ridotto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Riduce questo nodo a un'espressione più semplice.Se CanReduce restituisce true, deve essere restituita un'espressione valida.Questo metodo può restituire un altro nodo che deve essere a sua volta ridotto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Riduce l'espressione a un tipo di nodo noto (diverso da un nodo di estensione) o restituisce solo l'espressione se è già un tipo noto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianze di riferimento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianze di riferimento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione con un tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</returns>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Return, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return con il tipo specificato.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Return, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di spostamento a destra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di spostamento a destra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e la cui proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> è impostata sul valore specificato.</returns>
      <param name="variables">Raccolta di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e la cui proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> è impostata sul valore specificato.</returns>
      <param name="variables">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un oggetto a <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzioneswitch senza un case predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'opzione.</param>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un case predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'opzione.</param>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> da usare in un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> creato.</returns>
      <param name="body">Corpo del case.</param>
      <param name="testValues">Valori di test del case.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> da usare in un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> creato.</returns>
      <param name="body">Corpo del case.</param>
      <param name="testValues">Valori di test del case.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> la cui proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> è impostata sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> con le proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> le cui proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> sono impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> con le proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la generazione di un'eccezione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'eccezione.</returns>
      <param name="value">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la generazione di un'eccezione con un tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'eccezione.</returns>
      <param name="value">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Restituisce una rappresentazione testuale di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Rappresentazione testuale di <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con qualsiasi numero di istruzioni catch e nessun blocco fault o finally.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="handlers">Matrice di zero o più espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con qualsiasi numero di istruzioni catch e un blocco finally.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.</param>
      <param name="handlers">Matrice di zero o più espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto a <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con un blocco fault e nessuna istruzione catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="fault">Corpo del blocco fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con un blocco finally e nessuna istruzione catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Action generico con argomenti di tipo specifici.</summary>
      <returns>true se il tipo delegato System.Action generico è stato creato per <paramref name="typeArgs" /> specifico; in caso contrario, false.</returns>
      <param name="typeArgs">Matrice di oggetti Type che specificano gli argomenti di tipo per il tipo delegato System.Action.</param>
      <param name="actionType">Quando questo metodo viene restituito, contiene il tipo delegato System.Action generico che dispone di argomenti di tipo specifici.Contiene Null se nessun delegato System.Action generico corrisponde all'oggetto <paramref name="typeArgs" />. Questo parametro viene passato non inizializzato.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Func generico con argomenti di tipo specifici.L'ultimo argomento di tipo specifica il tipo restituito del delegato creato.</summary>
      <returns>true se il tipo delegato System.Func generico è stato creato per <paramref name="typeArgs" /> specifico; in caso contrario, false.</returns>
      <param name="typeArgs">Matrice di oggetti Type che specificano gli argomenti di tipo per il tipo delegato System.Func.</param>
      <param name="funcType">Quando questo metodo viene restituito, contiene il tipo delegato System.Func generico con argomenti di tipo specifici.Contiene Null se nessun delegato System.Func generico corrisponde all'oggetto <paramref name="typeArgs" />. Questo parametro viene passato non inizializzato.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un riferimento esplicito o una conversione boxing in cui viene fornito null se la conversione non riesce.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> che confronta l'identità del tipo in fase di esecuzione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> per il quale la proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> e per il quale le proprietà <see cref="T:System.Linq.Expressions.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> per il quale la proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> e per il quale le proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione con il più unario.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore più unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione con il più unario.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore più unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta una conversione unboxing esplicita.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> di cui eseguire la conversione unboxing.</param>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati.</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
      <param name="name">Nome del parametro o della variabile.Questo nome viene usato solo a scopo di debug o di stampa.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Riduce il nodo, quindi chiama il delegato del visitatore sull'espressione ridotta.Se il nodo non è riducibile, il metodo genera un'eccezione.</summary>
      <returns>Espressione visitata o espressione che deve sostituirla nell'albero.</returns>
      <param name="visitor">Istanza di <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Rappresenta un'espressione lambda fortemente tipizzata come struttura dei dati sotto forma di una struttura ad albero dell'espressione.La classe non può essere ereditata.</summary>
      <typeparam name="TDelegate">Tipo del delegato rappresentato dall'oggetto <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila l'espressione lambda descritta dalla struttura ad albero dell'espressione in codice eseguibile e produce un delegato che rappresenta l'espressione lambda.</summary>
      <returns>Delegato di tipo <paramref name="TDelegate" /> che rappresenta l'espressione lambda compilata descritta dall'oggetto <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del risultato.</param>
      <param name="parameters">Proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del risultato. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Descrive i tipi dei nodi di una struttura ad albero dell'espressione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Operazione di addizione, ad esempio a + b, senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Operazione di assegnazione composta di addizione, ad esempio (a += b), senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Operazione di assegnazione composta di addizione, ad esempio (a += b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Operazione di addizione, ad esempio (a + b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Operazione AND bit per bit o logica, ad esempio (a &amp; b) in C# e (a And b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Operazione AND condizionale che valuta il secondo operando solo se il primo operando restituisce true.Corrisponde a (a &amp;&amp; b) in C# e a (a AndAlso b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Operazione di assegnazione composta AND bit per bit o logica, ad esempio (a &amp;= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Operazione di indicizzazione in una matrice unidimensionale, quale array[index] in C# o array(index) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Operazione che ottiene la lunghezza di una matrice unidimensionale, ad esempio array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Operazione di assegnazione, ad esempio (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Blocco di espressioni.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Chiamata a un metodo, ad esempio nell'espressione obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nodo che rappresenta un'operazione null coalescing, ad esempio (a ?? b) in C# o If(a, b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Operazione condizionale, ad esempio a &gt; b ? a : b in C# o If(a &gt; b, a, b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Valore costante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Operazione cast o di conversione, ad esempio (SampleType)obj in C# o CType(obj, SampleType) in Visual Basic.Nel caso di una conversione numerica, se il valore convertito è troppo lungo per il tipo di destinazione non viene generata alcuna eccezione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Operazione cast o di conversione, ad esempio (SampleType)obj in C# o CType(obj, SampleType) in Visual Basic.Nel caso di una conversione numerica, se il valore convertito è troppo lungo per il tipo di destinazione viene generata un'eccezione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informazioni sul debug.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Operazione di decremento unaria quale (a - 1) in C# e Visual Basic.È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Valore predefinito.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Operazione di divisione, ad esempio (a / b), per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Operazione di assegnazione composta di divisione, ad esempio (a /= b), per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Operazione dinamica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nodo che rappresenta un confronto di uguaglianze, ad esempio (a == b) in C# o (a = b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Operazione XOR bit per bit o logica, ad esempio (a ^ b) in C# o (a Xor b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Operazione di assegnazione composta XOR bit per bit o logica, ad esempio (a ^= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Espressione di estensione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Espressione "go to", ad esempio goto Label in C# o GoTo Label in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Confronto "maggiore di", ad esempio (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Confronto "maggiore o uguale a", ad esempio (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Operazione di incremento unaria quale (a + 1) in C# e Visual Basic.È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Operazione di indicizzazione o operazione che accede a una proprietà che accetta argomenti. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Operazione che richiama un delegato o un'espressione lambda, ad esempio sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valore condizionale false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valore condizionale true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Etichetta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Espressione lambda, ad esempio a =&gt; a + a in C# o Function(a) a + a in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Operazione di scorrimento a sinistra bit per bit, ad esempio (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Assegnazione composta di scorrimento a sinistra bit per bit, ad esempio (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Confronto "minore di", ad esempio (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Confronto "minore o uguale a", ad esempio (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Operazione che crea un nuovo oggetto <see cref="T:System.Collections.IEnumerable" /> e lo inizializza da un elenco di elementi, ad esempio new List&lt;SampleType&gt;(){ a, b, c } in C# o Dim sampleList = { a, b, c } in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Ciclo, ad esempio for o while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Operazione che legge da un campo o una proprietà, ad esempio obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Operazione che crea un nuovo oggetto e ne inizializza uno o più membri, ad esempio new Point { X = 1, Y = 2 } in C# o New Point With {.X = 1, .Y = 2} in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Operazione di resto aritmetica, ad esempio (a % b) in C# o (a Mod b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Operazione di assegnazione composta di resto aritmetica, ad esempio (a %= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Operazione di moltiplicazione, ad esempio (a * b), senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Operazione di assegnazione composta di moltiplicazione, ad esempio (a *= b), senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Operazione di assegnazione composta di moltiplicazione, ad esempio (a *= b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Operazione di moltiplicazione, ad esempio (a * b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Operazione di negazione aritmetica, ad esempio (-a).È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Operazione di negazione aritmetica, ad esempio (-a), con controllo dell'overflow.È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Operazione che chiama un costruttore per creare un nuovo oggetto, ad esempio new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Operazione che crea una nuova matrice in cui sono specificati i limiti per ogni dimensione, ad esempio new SampleType[dim1, dim2] in C# o New SampleType(dim1, dim2) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Operazione che crea una nuova matrice unidimensionale e la inizializza da un elenco di elementi, ad esempio new SampleType[]{a, b, c} in C# o New SampleType(){a, b, c} in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Operazione di negazione logica o di complemento bit per bit.In C#, è equivalente a (~a) per i tipi integrali e a (!a) per i valori booleani.In Visual Basic, è equivalente a (Not a).È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Confronto di disuguaglianze, ad esempio (a != b) in C# o (a &lt;&gt; b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Operazione di complemento a uno, ad esempio (~a) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Operazione OR bit per bit o logica, ad esempio (a | b) in C# o (a Or b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Assegnazione composta OR bit per bit o logica, ad esempio (a |= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Operazione OR condizionale di corto circuito, ad esempio (a || b) in C# o (a OrElse b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Riferimento a un parametro o una variabile definiti nel contesto dell'espressione.Per ulteriori informazioni, vedere <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Forma suffissa di decremento unario, ad esempio (a--).È necessario che l'oggetto a venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Forma suffissa di incremento unario, ad esempio (a++).È necessario che l'oggetto a venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Operazione matematica che eleva un numero a potenza, ad esempio (a ^ b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Operazione di assegnazione composta che eleva un numero a potenza, ad esempio (a ^= b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Forma prefissa di decremento unario, ad esempio (--a).È necessario che l'oggetto a venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Forma prefissa di incremento unario, ad esempio (++a).È necessario che l'oggetto a venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Espressione che ha un valore costante di tipo <see cref="T:System.Linq.Expressions.Expression" />.Un nodo <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> può contenere riferimenti ai parametri definiti nel contesto dell'espressione che rappresenta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Operazione di scorrimento a destra bit per bit, ad esempio (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Operazione di assegnazione composta di scorrimento a destra bit per bit, ad esempio (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Elenco di variabili di run-time.Per ulteriori informazioni, vedere <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Operazione di sottrazione, ad esempio (a - b), senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Operazione di assegnazione composta di sottrazione, ad esempio (a -= b), senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Operazione di assegnazione composta di sottrazione, ad esempio (a -= b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Operazione di sottrazione aritmetica, ad esempio (a - b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Operazione di switch, ad esempio switch in C# o Select Case in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Operazione che genera un'eccezione, ad esempio throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Espressione try-catch.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Riferimento esplicito o conversione boxing in cui viene specificato null se la conversione non riesce, ad esempio (obj as SampleType) in C# o TryCast(obj, SampleType) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Test di tipo esatto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Test di tipo, ad esempio obj is SampleType in C# o TypeOf obj is SampleType in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Operazione con il più unario, ad esempio (+a).Il risultato di un'operazione con il più unario predefinita è il valore dell'operando, ma le implementazioni definite dall'utente possono dare risultati insoliti.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Operazione di unboxing del tipo di valore, ad esempio le istruzioni unbox e unbox.any in MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Rappresenta un visitatore o un rewriter per le strutture ad albero dell'espressione.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inizializza una nuova istanza di <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Invia l'elenco di espressioni a uno dei metodi di visita più specializzati in questa classe.</summary>
      <returns>L'elenco modificato delle espressioni, se è stato modificato uno degli elementi; in caso contrario, restituisce l'elenco originale delle espressioni.</returns>
      <param name="nodes">Espressioni da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita tutti i nodi nella raccolta utilizzando un visitatore dell'elemento specificato.</summary>
      <returns>Elenco modificato dei nodi, se è stato modificato uno degli elementi. In caso contrario, restituisce l'elenco originale dei nodi.</returns>
      <param name="nodes">I nodi da visitare.</param>
      <param name="elementVisitor">Un delegato che visita un solo elemento, sostituendolo facoltativamente con un nuovo elemento.</param>
      <typeparam name="T">Il tipo di tutti i nodi.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Invia l'espressione a uno dei metodi di visita più specializzati in questa classe.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visita un'espressione, eseguendo il cast del risultato sul tipo di espressione originale.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="nodes">Espressione da visitare.</param>
      <param name="callerName">Nome del metodo chiamante. Utilizzato per segnalare un messaggio di errore migliore.</param>
      <typeparam name="T">Il tipo dell'espressione.</typeparam>
      <exception cref="T:System.InvalidOperationException">Il metodo di visita per questo nodo ha restituito un tipo diverso.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita un'espressione, eseguendo il cast del risultato sul tipo di espressione originale.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
      <param name="callerName">Nome del metodo chiamante. Utilizzato per segnalare un messaggio di errore migliore.</param>
      <typeparam name="T">Il tipo dell'espressione.</typeparam>
      <exception cref="T:System.InvalidOperationException">Il metodo di visita per questo nodo ha restituito un tipo diverso.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita i figli dell'espressione di estensione.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
      <typeparam name="T">Tipo del delegato.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Rappresenta un salto incondizionato.Include istruzioni di ritorno, interruzione e continuazione, e altri salti.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Il tipo di espressione "go to".Ha solo scopi di informazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> che rappresenta il tipo dell'espressione "go to".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>L'etichetta della destinazione a cui salta questo nodo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta l'etichetta destinazione per questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="target">Proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del risultato. </param>
      <param name="value">Proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del risultato. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Il valore passato alla destinazione, oppure Null se la destinazione è di tipo System.Void.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il valore passato alla destinazione, oppure Null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Specifica che tipo di salto che questo <see cref="T:System.Linq.Expressions.GotoExpression" /> rappresenta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di interruzione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di continuazione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Un <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un salto a una determinata posizione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di ritorno.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Rappresenta l'indicizzazione di una proprietà o di una matrice.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Ottiene gli argomenti che verranno utilizzati per indicizzare la proprietà o la matrice.</summary>
      <returns>Raccolta di sola lettura contenente gli argomenti che verranno utilizzati per indicizzare la proprietà o la matrice.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Ottiene <see cref="T:System.Reflection.PropertyInfo" /> per la proprietà se l'espressione rappresenta una proprietà indicizzata, restituisce Null in caso contrario.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> per la proprietà se l'espressione rappresenta una proprietà indicizzata; in caso contrario Null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Un oggetto da indicizzare.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto da indicizzare.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="object">Proprietà <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Rappresenta un'espressione che applica un delegato o un'espressione lambda a un elenco di espressioni argomento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Ottiene gli argomenti a cui viene applicato il delegato o l'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Ottiene il delegato o l'espressione lambda da applicare.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato da applicare.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Rappresenta un'etichetta che può essere inserita in qualsiasi contesto <see cref="T:System.Linq.Expressions.Expression" />.Se viene raggiunto, otterrà il valore fornito dal corrispondente <see cref="T:System.Linq.Expressions.GotoExpression" />.In caso contrario, riceve il valore in <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Se <see cref="T:System.Type" /> è uguale a System.Void, non deve essere fornito alcun valore.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Il valore di <see cref="T:System.Linq.Expressions.LabelExpression" /> quando l'etichetta viene raggiunta tramite flusso di controllo normale (ad esempio, non ci si è arrivati tramite un salto).</summary>
      <returns>Oggetto Expression che rappresenta il valore dell'oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale è associata questa etichetta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale è associata questa etichetta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="target">Proprietà <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del risultato.</param>
      <param name="defaultValue">Proprietà <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilizzato per rappresentare la destinazione di un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Ottiene il nome dell'etichetta.</summary>
      <returns>Nome dell'etichetta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Il tipo di valore passato saltando all'etichetta (o <see cref="T:System.Void" /> se non deve essere passato alcun valore).</summary>
      <returns>L'oggetto <see cref="T:System.Type" /> che rappresenta il tipo di valore passato saltando all'etichetta, oppure <see cref="T:System.Void" /> se non deve essere passato alcun valore</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Descrive un'espressione lambda.Acquisisce un blocco di codice analogo a un corpo di metodo .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Ottiene il corpo dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo dell'espressione lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produce un delegato che rappresenta l'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Delegate" /> contenente la versione compilata dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Ottiene il nome dell'espressione lambda.</summary>
      <returns>Nome dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Ottiene i parametri dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresentano i parametri dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Ottiene il tipo di ritorno dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Ottiene il valore che indica se l'espressione lambda sarà compilata con l'ottimizzazione della chiamata tail.</summary>
      <returns>Vero se l'espressione lambda sarà compilata con l'ottimizzazione della chiamata tail; in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Rappresenta una chiamata al costruttore con un inizializzatore di raccolta.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se il nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Ottiene gli inizializzatori di elementi utilizzati per inizializzare una raccolta.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> che rappresentano gli elementi utilizzati per inizializzare la raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Ottiene l'espressione che contiene una chiamata al costruttore di un tipo di raccolta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore di un tipo di raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Riduce il nodo dell'espressione binaria a un'espressione più semplice.</summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="newExpression">Proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del risultato.</param>
      <param name="initializers">Proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Rappresenta un ciclo infinito.È possibile uscire con "interruzione."</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che costituisce il corpo del ciclo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che costituisce il corpo del ciclo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di interruzione.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come destinazione dell'istruzione di interruzione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di continuazione.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di continuazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="breakLabel">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del risultato.</param>
      <param name="continueLabel">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Rappresenta l'operazione di assegnazione per un campo o una proprietà di un oggetto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Ottiene l'espressione da assegnare al campo o alla proprietà.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il valore da assegnare al campo o alla proprietà.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fornisce la classe di base dalla quale derivano le classi che rappresentano le associazioni utilizzate per inizializzare i membri di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Ottiene il tipo di associazione rappresentato.</summary>
      <returns>Uno dei valori di <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Ottiene il campo o la proprietà da inizializzare.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta il campo o la proprietà da inizializzare.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Restituisce una rappresentazione testuale di <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Rappresentazione testuale di <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Descrive i tipi di associazione utilizzati negli oggetti <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Associazione che rappresenta l'inizializzazione di un membro con il valore di un'espressione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Associazione che rappresenta l'inizializzazione di un membro di tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> da un elenco di elementi.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Associazione che rappresenta l'inizializzazione ricorsiva dei membri di un membro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Rappresenta l'accesso a un campo o a una proprietà.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Ottiene l'oggetto contenitore del campo o della proprietà.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto contenitore del campo o della proprietà.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Ottiene il campo o la proprietà a cui accedere.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta il campo o la proprietà a cu accedere.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Rappresenta la chiamata a un costruttore e l'inizializzazione di uno o più membri del nuovo oggetto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Ottiene le associazioni che descrivono come inizializzare i membri dell'oggetto appena creato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> che descrivono come inizializzare i membri.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se il nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Ottiene l'espressione che rappresenta la chiamata al costruttore.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Riduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a un'espressione più semplice. </summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="newExpression">Proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del risultato.</param>
      <param name="bindings">Proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Rappresenta l'inizializzazione degli elementi di un membro di raccolta di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Ottiene gli inizializzatori di elemento per l'inizializzazione di un membro di raccolta di un oggetto appena creato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> con cui inizializzare un membro di raccolta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="initializers">Proprietà <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Rappresenta l'inizializzazione dei membri di un membro di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Ottiene le associazioni che descrivono come inizializzare i membri di un membro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> che descrivono come inizializzare i membri del membro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="bindings">Proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Rappresenta una chiamata a un metodo statico o di istanza.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Ottiene una raccolta di espressioni che rappresentano gli argomenti del metodo chiamato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del metodo chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Ottiene l'oggetto <see cref="T:System.Reflection.MethodInfo" /> per il metodo da chiamare.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'istanza per le chiamate ai metodi di istanza oppure null per le chiamate ai metodi statici.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto ricevente del metodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="object">Proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Rappresenta la creazione di una nuova matrice e la possibile inizializzazione degli elementi della nuova matrice.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Ottiene i limiti della matrice se il valore della proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> o i valori per inizializzare gli elementi della nuova matrice se il valore della proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano i limiti della matrice o i valori di inizializzazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expressions">Proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Rappresenta una chiamata a un costruttore.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Ottiene gli argomenti del costruttore.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Ottiene il costruttore chiamato.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Ottiene i membri che possono recuperare i valori dei campi inizializzati con gli argomenti del costruttore.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri che possono recuperare i valori dei campi inizializzati con gli argomenti del costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Rappresenta un'espressione del parametro denominato.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica che questo ParameterExpression deve essere trattato come un parametro ByRef.</summary>
      <returns>True se questo oggetto ParameterExpression è un parametro ByRef. In caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Ottiene il nome del parametro o della variabile.</summary>
      <returns>
        <see cref="T:System.String" /> che contiene il nome del parametro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Un'espressione che fornisce autorizzazione di lettura e scrittura per le variabili al runtime.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variables">Proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del risultato.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Le variabili o parametri alle quali fornire accesso al runtime.</summary>
      <returns>La raccolta di sola lettura che contiene i parametri a cui sarà forniti l'accesso al runtime.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Rappresenta un case di un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Ottiene il corpo di questo case.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo di un blocco case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Ottiene i valori di questo case.Questo case viene selezionato per l'esecuzione quando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> corrisponde a qualsiasi valore.</summary>
      <returns>La raccolta di sola lettura dei valori per questo blocco case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="testValues">Proprietà <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Rappresenta un'espressione di controllo che gestisce più selezioni passando il controllo a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Ottiene la raccolta di oggetti <see cref="T:System.Linq.Expressions.SwitchCase" /> per l'opzione.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Ottiene il metodo di confronto di uguaglianze, se presente.</summary>
      <returns>Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di confronto di uguaglianze.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Ottiene il test per lo switch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test per lo switch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Ottiene il test per lo switch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test per lo switch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="switchValue">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del risultato.</param>
      <param name="cases">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del risultato.</param>
      <param name="defaultBody">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Archivia le informazioni necessarie per generare informazioni sui simboli del debug per un file di origine, in particolare il nome file e l'identificatore del linguaggio univoco.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Restituisce l'identificatore univoco del tipo di documento, se presente.Imposta come valore predefinito a GUID per un file di testo.</summary>
      <returns>Identificatore univoco del tipo di documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nome del file di origine.</summary>
      <returns>Stringa che rappresenta il nome del file di origine.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Restituisce l'identificatore univoco del linguaggio, se presente.</summary>
      <returns>Identificatore univoco del linguaggio</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Restituisce l'identificatore univoco del fornitore del linguaggio, se presente.</summary>
      <returns>Identificatore univoco del fornitore del linguaggio.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Rappresenta un blocco try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del blocco try.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del blocco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Ottiene la raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> associate al blocco try.</summary>
      <returns>Raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> associate al blocco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del risultato.</param>
      <param name="handlers">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del risultato.</param>
      <param name="finally">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del risultato.</param>
      <param name="fault">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Rappresenta un'operazione tra un'espressione e un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Ottiene l'operando dell'espressione di un'operazione di test del tipo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando dell'espressione di un'operazione di test del tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Ottiene l'operando del tipo di un'operazione di test del tipo.</summary>
      <returns>
        <see cref="T:System.Type" /> che rappresenta l'operando del tipo di un'operazione di test del tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Rappresenta un'espressione che ha un operatore unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se un nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore.</summary>
      <returns>true se il nodo rappresenta una chiamata elevata; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore il cui tipo restituito è elevato a un tipo nullable.</summary>
      <returns>true se il tipo restituito dell'operatore è elevato a un tipo nullable; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Ottiene il metodo di implementazione per l'operazione unaria.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Ottiene l'operando dell'operazione unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando dell'operazione unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Riduce il nodo dell'espressione a un'espressione più semplice. </summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="operand">Proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del risultato.</param>
    </member>
  </members>
</doc>